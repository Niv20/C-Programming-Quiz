// quizzes/other.js
const quizData = [
  {
    code: `void GenBubbleSort( void *v, unsigned int numOfElements, 
                  unsigned int elementSize, int (*compare)(void *, void *))
{
    int i, j;
    char sorted = 0;
    void *v_j, *v_j1, *tmp;

    for (i = numOfElements - 1; i > 0 && !sorted; i--)
    {
        sorted = 1;
        for (j = 0; j < i; j++)
        {
            v_j = (void *)((char *)v + j*elementSize);

            [[1]]

            if ( (*compare)( v_j, v_j1) > 0)
            {
                /* החלפת התאים בכתובות v_j, v_j1 */
                sorted = 0;
            }
        }
    }
}`,
    question:
      "מהו קטע הקוד שיש למלא בתיבה 1 כדי לחשב נכונה את כתובת האיבר הבא לצורך ההשוואה במיון הבועות?",
    answers: [
      "`[[1: v_j1 = (void *)((char *)v_j + elementSize);]]`",
      "`[[1: v_j1 = (void *)((char *)v + (j+1)*elementSize);]]`",
      "`[[1: tmp = ((char *)v + elementSize); v_j1 = (void *)(&(tmp[v]));]]`",
      "`[[1: tmp = (char *)v; v_j1 = (void *)( tmp[(j+1)*elementSize] );]]`",
      "אף אחת מהתשובות לא נכונה",
      "יש יותר מתשובה אחת נכונה",
    ],
    correct: 5,
    hint: "במיון בועות משווים כל איבר עם האיבר שבא אחריו. הקוד כבר חישב את הכתובת של האיבר ה־`j` לתוך המשתנה `v_j`, ועלינו להשלים את חישוב הכתובת של האיבר ה־`j+1`. שימו לב למשתנה `tmp` בתשובות השגויות - מאיזה טיפוס הוא, והאם הפעולות שמנסים לבצע עליו חוקיות?",
    explanation:
      "תחילה, נפסול את שתי התשובות המשתמשות במשתנה `tmp`. משתנה זה הוא מטיפוס `void*`, שעליו לא ניתן לבצע פעולת אינדוקס באמצעות סוגריים מרובעים `[]`. ניסיון לעשות זאת הוא פעולה לא חוקית בשפת־C ויוביל לשגיאת קומפילציה.\n\nכעת נבחן את שתי התשובות הנותרות. האפשרות הראשונה בתיבה 1 היא נכונה. היא לוקחת את הכתובת של האיבר הנוכחי (`v_j`), מוסיפה לה את גודל האיבר (`elementSize`), ובכך מקבלת באופן ישיר ויעיל את הכתובת של האיבר הבא.\n\nהאפשרות השנייה בתיבה 1 היא גם נכונה. היא מחשבת את הכתובת של האיבר הבא (`j+1`) על ידי חישוב ההיסט המלא מתחילת המערך (`v`). למרות שהיא מעט פחות יעילה מהאפשרות הקודמת, היא מגיעה לאותה תוצאה נכונה מבחינה לוגית.\n\nמכיוון ששתי תשובות לפחות הן נכונות ומתאימות לביצוע המשימה, התשובה הנכונה ביותר היא שיש יותר מתשובה אחת נכונה.",
  },
  {
    code: `typedef void(*Func)(void*);

int count = 0;

void foo2(void* f);

void foo1(void* f) {
    printf("foo1 ");
    count++;
    
    if (f == foo1 || count == 4)
        return;
    
    ((Func)f)(foo1);
}

void foo2(void* f) {
    printf("foo2 ");
    count++;

    if (f == foo2 || count == 4)
        return;

    ((Func)f)(foo2);
}

void main() {
    foo1(foo1);
    foo1(foo2);
}`,
    question: "מהו הפלט של התכנית הבאה?",
    answers: [
      "`foo1 foo1 foo2 foo1`",
      "`foo1 foo1 foo1 foo2`",
      "התכנית לא עוברת קומפילציה",
      "התכנית נכנסת ללולאה אינסופית",
      "יתר התשובות אינן נכונות",
    ],
    correct: 0,
    hint: "עקבו אחר שרשרת הקריאות בין הפונקציות `foo1` ו־`foo2`. שימו לב במיוחד כיצד המונה הגלובלי `count` ותנאי העצירה בכל פונקציה משפיעים על סיום הרקורסיה ההדדית.",
    explanation:
      'הקריאה הראשונה מהפונקציה `main` היא `foo1(foo1)`. בתוך `foo1`, הפלט "foo1 " מודפס, המונה הגלובלי `count` גדל ל־1, ותנאי העצירה `f == foo1` מתקיים. לכן הפונקציה חוזרת מיד.\nהקריאה השנייה היא `foo1(foo2)`. הפלט "foo1 " מודפס ו־`count` הופך ל־2. תנאי העצירה אינו מתקיים, ולכן מתבצעת קריאה ל־`((Func)f)(foo1)`, שהיא למעשה `foo2(foo1)`. בתוך `foo2`, הפלט "foo2 " מודפס ו־`count` הופך ל־3. שוב, תנאי העצירה לא מתקיים והפעם מתבצעת קריאה ל־`foo1(foo2)`.\nבקריאה האחרונה ל־`foo1(foo2)`, הפלט "foo1 " מודפס ו־`count` הופך ל־4. כעת, תנאי העצירה `count == 4` מתקיים, והפונקציה חוזרת. שרשרת הקריאות מסתיימת, והפלט הסופי שהודפס הוא `foo1 foo1 foo2 foo1`.',
  },
  {
    code: `typedef struct Node {
    char *data;
    struct Node *next;
} Node;

typedef struct List {
    Node *head, *tail;
} List;

void FreeNode(Node *node_to_free){
    free(node_to_free->data);
    free(node_to_free);
}

void DeleteFirst(List *list) {
    Node *node_to_delete = list->head;
    list->head = list->head->next;
    FreeNode(node_to_delete);
    
    if (list->head == NULL)
        list->tail = NULL;
}

void DeleteList(List *list) {
    while (list->head)
        DeleteFirst(list);
        
    free(list);
}`,
    question: "איזו מבין הטענות הבאות היא הנכונה ביותר:",
    answers: [
      "הפונקציה `DeleteList` תעבוד בצורה תקינה רק אם המשתנה `list` מצביע למקום שהוקצה דינאמית",
      "הפונקציה `DeleteList` תמיד תניב שגיאת זמן ריצה בעת ביצוע ה־`free`",
      "הפונקציה `DeleteList` תקינה ותעבוד בכל המקרים",
      "יש להעביר את פקודת ה־`free` אל הפונקציה הקוראת מיד לאחר הקריאה ל־`DeleteList` כדי להימנע משגיאת זמן ריצה",
      "קטע הקוד לא יעבור קומפילציה",
      "אף תשובה מהתשובות האחרות אינה נכונה",
    ],
    correct: 0,
    hint: "שימו לב לפעולה האחרונה שמתבצעת בפונקציה `DeleteList`. על אילו סוגי משתנים מותר לקרוא לפקודה `free`, ומה יקרה אם נקרא לה על משתנה שלא הוקצה באופן המתאים?",
    explanation:
      "הבעייתיות בקוד טמונה בשורה האחרונה של הפונקציה `DeleteList`, והיא `free(list)`. פקודת `free` בשפת־C מיועדת לשחרור זיכרון שהוקצה באופן דינאמי על 'הערימה' (heap), למשל באמצעות `malloc`. אם מתכנת יקרא לפונקציה `DeleteList` עם מצביע למבנה `List` שנוצר על 'המחסנית' (stack), הקריאה `free(list)` תגרום להתנהגות בלתי צפויה, ולרוב לקריסת התוכנית. לכן, תקינות הפונקציה תלויה לחלוטין בכך שהמשתנה `list` מצביע לזיכרון שהוקצה דינאמית.\n\nשאר התשובות אינן נכונות. הפונקציה לא תמיד תניב שגיאה, כיוון שהיא תעבוד נכון עבור רשימה שהוקצתה דינאמית, ולכן הטענה שהיא תמיד תקינה אינה נכונה. העברת פקודת ה־`free` החוצה היא שינוי עיצובי שמשנה את אחריות הפונקציה, ולא תיקון לבאג. לבסוף, הקוד תקין מבחינה תחבירית ויעבור קומפילציה ללא שגיאות.",
  },
  {
    code: `typedef struct {
    char* name;
    int serialNum;
    double price;
} Product;

Product **arr;

void *a = &arr[0];
void *b = &arr[1];

int compare1(void *a, void *b)
{
    return strcmp(((Product*)a)->name, ((Product*)b)->name);
}

int compare2(void *a, void *b)
{
    return strcmp((*((Product**)a))->name, (*((Product**)b))->name);
}

int compare3(void *a, void *b)
{
    return strcmp((*(Product*)a).name, (*(Product*)b).name);
}

int compare4(void *a, void *b)
{
    return strcmp((**((Product**)a)).name, (**((Product**)b)).name);
}`,
    question:
      "בהינתן הקוד המוצג, איזו פונקציית השוואה (`compare`) תבצע כראוי השוואה לקסיקוגרפית בין שמות המוצרים המאוחסנים ב־`arr[0]` וב־`arr[1]`?",
    answers: [
      "יותר מאחת מהן",
      "`compare1`",
      "`compare2`",
      "`compare3`",
      "`compare4`",
    ],
    correct: 0,
    hint: "חשבו היטב מהו הטיפוס האמיתי של המשתנים `a` ו־`b`. הם מוגדרים כ־`void*`, אך לאיזה סוג של נתון הם למעשה מצביעים? הבנת רמות ההצבעה (indirection) היא המפתח לפענוח ההמרה והגישה הנכונה לשדה `name`.",
    explanation:
      "כדי לגשת לשדה `name`, יש להבין את מבנה הנתונים. המשתנה `arr` הוא מצביע למצביע למוצר (`Product**`). לכן, `arr[0]` הוא מצביע למוצר (`Product*`). המשתנים `a` ו־`b` מקבלים את הכתובת של איברי המערך (`&arr[0]`), כלומר הם מצביעים למצביע למוצר. הטיפוס האמיתי שהם מחזיקים הוא `Product**`.\n\nהפונקציות `compare2` ו־`compare4` פועלות נכון. `compare2` מבצעת המרה (`cast`) לטיפוס הנכון (`Product**`), מבצעת `dereference` אחד (`*`) כדי לקבל מצביע למוצר (`Product*`), ומשתמשת באופרטור החץ (`->`) כדי לגשת לשדה. `compare4` מבצעת גם היא המרה נכונה, אך מבצעת `dereference` כפול (`**`) כדי להגיע ישירות למבנה המוצר עצמו, ואז ניגשת לשדה באמצעות אופרטור הנקודה (`.`). שתי הדרכים שקולות לחלוטין.\n\nלעומת זאת, הפונקציות `compare1` ו־`compare3` נכשלות. שתיהן מבצעות המרה שגויה של המצביעים לטיפוס `Product*` במקום `Product**`. המרה לא נכונה זו גורמת לפרשנות שגויה של הזיכרון, מה שיוביל לתוצאה שגויה או לקריסת התוכנית.",
  },
  {
    code: `typedef struct _Student
{
    unsigned long id;
    char *name;
    unsigned int grade;
} Student;

// נתון מערך של מצביעים לסטודנטים
Student **students;

// ... המערך הוקצה, הנתונים הוכנסו ...

// נתונה הקריאה הבאה לפונקציה
CompareStudentsNames( students[5], students+10 );

int CompareStudentsNames( void *p1, void *p2 )
{
    return ( strcmp( [[1]] , [[2]] ) );
}`,
    question:
      "בהינתן הקוד והקריאה לפונקציה, מה יש למלא בתיבות 1 ו-2 כדי שהפונקציה תשלים כראוי את השוואת השמות המתאימים לפרמטרים `p1` ו־`p2`?",
    answers: [
      "`[[1: ((Student*)p1)->name]][[2: (*((Student**)p2))->name]]`",
      "`[[1: (*((Student**)p1))->name]][[2: (*((Student**)p2))->name]]`",
      "`[[1: (**((Student**)p1)).name]][[2: (**((Student**)p2)).name]]`",
      "`[[1: ((Student*)p1)->name]][[2: ((Student*)p2).name]]`",
      "אף תשובה מבין התשובות האחרות אינה נכונה",
    ],
    correct: 0,
    hint: "שימו לב היטב להבדל בין שני הארגומנטים המועברים לפונקציה. מהו הטיפוס של `students[5]` ומהו הטיפוס של `students+10`? לכל אחד מהם נדרשת דרך גישה שונה כדי להגיע לשדה `name`.",
    explanation:
      "הפתרון הנכון דורש הבנה מדויקת של טיפוסי המשתנים המועברים לפונקציה. המערך `students` הוא מצביע למצביע (`Student**`), לכן `students[5]` הוא מצביע לסטודנט (`Student*`), בעוד שהביטוי `students+10` הוא כתובת בתוך מערך המצביעים, וטיפוסו הוא מצביע למצביע (`Student**`).\n\nהפרמטר `p1` מקבל את `students[5]`, ולכן כדי לגשת לשם דרכו, יש לבצע המרה ל־`Student*` ולהשתמש באופרטור החץ. לכן, בתיבה 1 יש למלא את הביטוי `((Student*)p1)->name`.\n\nהפרמטר `p2` מקבל את `students+10`. כדי לגשת לשם דרכו, יש לבצע המרה ל־`Student**`, לבצע `dereference` אחד (`*`) כדי לקבל את המצביע `students[10]`, ורק אז להשתמש באופרטור החץ. לכן, בתיבה 2 יש למלא את הביטוי `(*((Student**)p2))->name`.",
  },
  {
    code: `typedef struct _Student
{
    unsigned long id;
    char *name;
    unsigned int grade;
} Student;

Student **students;


// נניח שהמערך הוקצה, וכל איבריו מצביעים לסטודנטים קיימים

CompareStudentsNames( students[5], students+10 );

int CompareStudentsNames( [[1]] p1, [[2]] p2 )
{
    return ( strcmp( [[3]] , [[4]] ) );
}`,
    question:
      "מה יש למלא בתיבות 1, 2, 3 ו-4 כדי שהפונקציה תשווה בין שם הסטודנט שמוצבע מתא 10 במערך `students` לבין שם הסטודנט שמוצבע מתא 5?",
    answers: [
      "`[[1: Student*]][[2: Student**]][[3: (*p2)->name]][[4: p1->name]]`",
      "`[[1: Student*]][[2: Student**]][[3: (*p1).name]][[4: (*p2)->name]]`",
      "`[[1: Student**]][[2: Student*]][[3: (*p1)->name]][[4: (*p2).name]]`",
      "`[[1: Student*]][[2: Student**]][[3: (**p1).name]][[4: (*p2)->name]]`",
      "אף תשובה מבין התשובות האחרות אינה נכונה",
    ],
    correct: 0,
    hint: "התחילו בזיהוי הטיפוס המדויק של כל אחד מהארגומנטים המועברים לפונקציה: `students[5]` ו־`students+10`. לאחר שתגדירו את טיפוסי הפרמטרים בתיבות 1 ו-2, הגדרת הגישה לשדה `name` בתיבות 3 ו-4 תהיה פשוטה יותר.",
    explanation:
      "כדי לפתור את השאלה, יש לנתח את הטיפוסים המועברים לפונקציה. הביטוי `students[5]` ניגש לאיבר במערך של מצביעים, ולכן טיפוסו הוא מצביע לסטודנט, `Student*`. לכן, בתיבה 1 יש להצהיר על `p1` כעל `Student*`.\n\nהביטוי `students+10` מבצע אריתמטיקה על המצביע הכפול `students`, ולכן התוצאה היא מצביע למצביע לסטודנט, `Student**`. לכן, בתיבה 2 יש להצהיר על `p2` כעל `Student**`.\n\nהשאלה מבקשת להשוות את שם הסטודנט מתא 10 (שהגיע דרך `p2`) לשם הסטודנט מתא 5 (שהגיע דרך `p1`). כדי לגשת לשם דרך `p2`, יש לבצע dereference אחד (`*p2`) כדי לקבל `Student*`, ואז להשתמש באופרטור החץ (`->`). לכן, בתיבה 3 נרשום `(*p2)->name`. כדי לגשת לשם דרך `p1`, שכבר מטיפוס `Student*`, נשתמש ישירות באופרטור החץ. לכן, בתיבה 4 נרשום `p1->name`.",
  },
  {
    code: `#define SWAP( SRC, DST, TMP, LEN) {\\
    memcpy(TMP, SRC, LEN);		\\
    memcpy(SRC, DST, LEN);		\\
    memcpy(DST, TMP, LEN);		\\
}

void swap(void *arr, unsigned int num_of_elements, unsigned int element_size)
{
    void *tmp, *an;
    int n = num_of_elements - 1;

    tmp = malloc(element_size);

    for ( ; n > 0; n -= 2)
    {
        an = ( [[1]] );
        SWAP( [[2]] , an, tmp, element_size);
    }

    free(tmp);
}`,
    question:
      "בהינתן שהפונקציה `swap` נועדה להחליף בין זוגות של איברים סמוכים החל מסוף המערך, מה יש למלא בתיבות 1 ו-2?",
    answers: [
      "אף תשובה מהתשובות האחרות אינה נכונה.",
      "`[[1: (void *)((char*)arr +(n-1)*element_size)]][[2: an+1]]`",
      "`[[1: (void *)((char*)arr + n*element_size)]][[2: an-1]]`",
      "`[[1: (char *)((void*)arr + n*element_size)]][[2: (void *)((char*)arr + (n-1)*element_size)]]`",
      "`[[1: (void *)((char*)arr + n*element_size)]][[2: (void *)((char*)an - 1)]]`",
      "שתי תשובות או יותר מהאחרות נכונות.",
    ],
    correct: 0,
    hint: "`an` הוא מצביע מטיפוס `void` ולכן לא ניתן לעשות לו `+1` או `-1`, ולכן שתי תשובות כבר נפסלות.",
    explanation:
      "אף אחת מהתשובות המוצעות אינה נכונה. כדי שהקוד יפעל כמצופה, יש לבצע חישובי כתובות מדויקים על מצביעים גנריים (`void*`), דבר הדורש המרה למצביע לבית (`char*`).\n\nבתיבה 1, המטרה היא להציב במשתנה `an` את הכתובת של האיבר במקום ה־`n`. הדרך הנכונה לעשות זאת היא לקחת את כתובת הבסיס של המערך `arr`, לבצע לה המרה ל־`char*`, להוסיף לה את ההיסט (offset) בבתים, שגודלו `n * element_size`, ואז להמיר חזרה ל־`void*`. לכן, הביטוי הנכון הוא: `(void*)((char*)arr + n * element_size)`.\n\nבתיבה 2, המטרה היא לספק לפונקציה `swap` את הכתובת של האיבר במקום ה־`n-1`, כלומר האיבר הקודם לזה שכתובתו נמצאת ב־`an`. מכיוון שכבר יש לנו את הכתובת של האיבר ה־`n`, הדרך היעילה ביותר היא לקחת את המצביע `an`, להמיר אותו ל־`char*`, להחסיר ממנו את גודל האיבר (`element_size`) כדי לחזור לאיבר הקודם, ולהמיר חזרה ל־`void*`. לכן, הביטוי הנכון הוא: `(void*)((char*)an - element_size)`.\n\nכפי שניתן לראות, אף אחת מהאפשרויות אינה מכילה את שני הביטויים הנכונים, ולכן התשובה היא שאף אחת מהתשובות האחרות לא נכונה.",
  },
  {
    code: `extern int x;

void main()
{
    int x = 10;
    a();
    b();
    c();
    a();
    b();
    c();
    printf("%d ", x);
}

void a()
{
    int x = 100;
    printf("%d ", x);
    x += 5;
}

void b()
{
    static int x = -10;
    printf("%d ", x);
    x += 5;
}

void c()
{
    printf("%d ", x);
    x += 2;
}

int x = 0;`,
    question: "מהו הפלט של תכנית זו?",
    answers: [
      "`100 -10 0 100 -5 2 10`",
      "התכנית לא מתקמפלת בגלל התנגשות בשמות משתנים",
      "התכנית לא מתקמפלת בגלל הגדרה שגויה או אתחול שגוי של משתנה גלובלי",
      "`100 -10 0 100 -5 2 2`",
      "כל התשובות אינן נכונות",
    ],
    correct: 0,
    hint: "אם נראה מוזר שהקוד מתקמפל למרות שהמשתנה הגלובלי `x` מוגדר בסוף הקובץ, שימו לב להצהרת ה־`extern` בתחילת הקוד. הצהרה זו מודיעה לקומפיילר על קיומו של המשתנה הגלובלי מראש.",
    explanation:
      "הקוד מדגים את כללי הנראות (scope) של משתנים ב-C. ראשית, הקוד עובר קומפילציה תקינה. הצהרת `extern int x;` בתחילת הקובץ מיידעת את הקומפיילר על קיומו של משתנה גלובלי בשם `x`, גם אם הגדרתו המלאה מופיעה בסוף הקובץ.\n\nהפונקציה `a` מגדירה משתנה מקומי חדש `x` בכל קריאה, ולכן תמיד תדפיס `100`. הפונקציה `b` מגדירה משתנה `static` מקומי `x`, המאותחל ל־-10 רק בקריאה הראשונה. ערכו נשמר בין הקריאות, ולכן בקריאה השנייה הוא ידפיס `-5`. הפונקציה `c` ניגשת למשתנה הגלובלי `x`, שמתחיל בערך `0` וגדל ב-2 בכל קריאה. לכן היא תדפיס `0` ואז `2`.\n\nלבסוף, פקודת ההדפסה בפונקציה `main` מתייחסת למשתנה המקומי של `main`, שערכו `10` לאורך כל ריצת התכנית. שרשור ההדפסות לפי סדר הקריאות נותן את הפלט המלא.",
  },
  {
    code: `int num = 10;

int f1() {
  static int num;
  num = 1;
  num++;
  return num - 1;
}

int f2() {
  static int num = 1;
  num++;
  return num - 1;
}

int f3() {
  num++;
  return num - 1;
}

void main() {
  int num;
  for (num = 0; num < 3; num++) {
    printf("%d %d %d \\t", f1(), f2(), f3());
  }
}`,
    question: "מהו הפלט של התכנית הבאה?",
    answers: [
      "`1 1 10\\t1 2 11\\t1 3 12`",
      "`1 1 10\\t1 2 10\\t1 3 10`",
      "`1 1 10\\t2 2 11\\t3 3 12`",
      "התכנית אינה מתקמפלת",
      "כל התשובות האחרות אינן נכונות",
    ],
    correct: 0,
    hint: "שימו לב להבדלים בין המשתנים השונים ששמם `num`. המשתנה בתוך `f1` מאותחל מחדש בכל קריאה, בעוד שהמשתנים ב-`f2` וב-`f3` שומרים על ערכם בין הקריאות. כמו כן, זכרו שהפעולה `num++` משנה את ערך המשתנה, אך הביטוי `num - 1` רק מחזיר ערך מחושב.",
    explanation:
      "השאלה בוחנת את ההבנה של טווח הכרזה (scope) של משתנים, ובמיוחד את ההבדל בין משתנה סטטי מקומי המאופס בכל קריאה, משתנה סטטי מקומי השומר על ערכו, ומשתנה גלובלי.\n\nבפונקציה `f1`, המשתנה הסטטי `num` מאותחל לאפס, אך מיד לאחר מכן מקבל את הערך 1 בכל קריאה. לכן, הפונקציה תמיד תחזיר את הערך `1`.\n\nבפונקציה `f2`, המשתנה הסטטי `num` מאותחל ל-1 רק בקריאה הראשונה. ערכו נשמר וגדל ב-1 בכל קריאה, ולכן הפונקציה תחזיר `1`, `2`, ו-`3` בסדר זה.\n\nהפונקציה `f3` עובדת על המשתנה הגלובלי `num` שערכו ההתחלתי הוא 10. ערך זה גדל בכל קריאה, ולכן הפונקציה תחזיר `10`, `11`, ו-`12`. שילוב הפלטים בכל איטרציה של הלולאה מוביל לתשובה הנכונה.",
  },
  {
    code: `void foo(int *a, int *b)
{
    static int *t;
    t = a;
    a = b;
    b = t;
}

void bar()
{
    static int i, a = -3, b = -6; 
    
    i = 0;
    while (i <= 4) {
        if (i % 2 == 1)
        {
            i++;
            continue;
        }
        
        i += 1;

        a = a + i;
        b += i;
    }
    
    foo(&a, &b);
    printf("%d %d ", a, b);
}

int main()
{
    bar();
    bar();
    return 0;
}`,
    question: "מהו הפלט של תכנית זו?",
    answers: [
      "כל התשובות האחרות אינן נכונות.",
      "`0 3 0 3`",
      "`3 6 3 6`",
      "`3 0 12 9`",
      "`6 3 15 12`",
    ],
    correct: 4,
    hint: "שימו לב שהפונקציה `foo` מקבלת העתקים של המצביעים, והחלפה ביניהם לא תשפיע על המשתנים המקוריים בפונקציה `bar`. בנוסף, זכרו שהמשתנים ב־`bar` הם סטטיים ושומרים על ערכם בין הקריאות.",
    explanation:
      "השאלה בוחנת שני עקרונות חשובים: העברת פרמטרים 'לפי ערך' והתנהגות של משתנים סטטיים. הפונקציה `foo` מקבלת העתקים של הכתובות של המשתנים `a` ו-`b` מהפונקציה `bar`. ההחלפה שהיא מבצעת היא בין ההעתקים המקומיים הללו, ואינה משפיעה כלל על המשתנים המקוריים ב-`bar`. לכן, לקריאה ל-`foo` אין השפעה על הפלט.\n\nהמשתנים `a` ו-`b` בפונקציה `bar` מוגדרים כסטטיים, כלומר הם מאותחלים פעם אחת בלבד (לערכים -3 ו--6) וערכיהם נשמרים בין קריאות לפונקציה. בקריאה הראשונה ל-`bar`, הלולאה רצה ומשנה את ערכי `a` ו-`b` ל-6 ו-3 בהתאמה, ואלו הערכים המודפסים.\n\nבקריאה השנייה ל-`bar`, המשתנים `a` ו-`b` מתחילים עם הערכים שבהם סיימו את הקריאה הקודמת (6 ו-3). הלולאה רצה שוב עם הערכים החדשים הללו, ומשנה אותם ל-15 ו-12, ואלו הערכים המודפסים. שרשור שני הפלטים נותן את התוצאה הסופית.",
  },
  {
    code: `void *FindMin( void *v, unsigned int numOfElements, unsigned int elementSize,
             int (*compare)(void *, void *))
{
    unsigned int i;
    void *min = v, *v_i;

    for (i = 1; i < numOfElements; i++)
    {
        v_i = (void *)((char *)v + i*elementSize);
        if ((*compare)( v_i, min) < 0)
            min = v_i;
    }
    return min;
}

// נתון מערך של מצביעים שבו כל תא מצביע לערך אחר מסוג int
int **arr;`,
    question:
      "בהינתן הפונקציה הגנרית `FindMin` ומערך מטיפוס `int **arr`, איזו מהמימושים הבאים של פונקציית ההשוואה `my_intcmp` תגרום ל-`FindMin` למצוא נכונה את הערך המינימלי במערך (על פי הערכים שהמצביעים מצביעים אליהם)?",
    answers: [
      "`int my_intcmp( int **s1, int **s2) { return (*s1 - *s2); }`",
      "`int my_intcmp( int *s1, int **s2) { return (*s1 - s2); }`",
      "`int my_intcmp( int **s1, int **s2) { return (**s1 - **s2); }`",
      "`int my_intcmp( int **s1, int *s2) { return (**s1 - *s2); }`",
      "אף אחד מהתשובות לא נכונה",
    ],
    correct: 2,
    hint: "הפונקציה הגנרית `FindMin` מעבירה לפונקציית ההשוואה מצביעים לאיברים במערך. חשבו מהו הטיפוס של איבר בודד במערך `int **arr`, ובהתאם, מהו הטיפוס של מצביע לאיבר כזה. כמה פעולות `dereference` (`*`) נדרשות כדי להגיע מהמצביע שמתקבל בפונקציה אל ערך ה-`int` הסופי?",
    explanation:
      "המערך הנתון הוא `int **arr`, כלומר מערך שכל איבר בו הוא מצביע למספר שלם (`int *`). הפונקציה `FindMin` מעבירה לפונקציית ההשוואה מצביעים לאיברים הללו, ולכן הפרמטרים `s1` ו-`s2` שהפונקציה `my_intcmp` מקבלת הם למעשה מצביעים למצביעים (`int **`).\n\nכדי להגיע לערך המספרי עצמו לצורך ההשוואה, יש צורך לבצע `dereference` כפול. ה-`dereference` הראשון (`*s1`) ייתן לנו את המצביע לאיבר (`int *`), וה-`dereference` השני (`**s1`) ייתן לנו את ערך ה-`int` הסופי שאליו המצביע מצביע. הפעולה `**s1 - **s2` מבצעת בדיוק את זה, ומחזירה את ההפרש בין שני המספרים השלמים, כנדרש מפונקציית השוואה.",
  },
  {
    code: `void GenBubbleSort( void *v, unsigned int numOfElements, 
                  unsigned int elementSize, int (*compare)(void *, void *))
{
    int i, j;
    void *v_j, *v_j1;

    for (i = numOfElements - 1; i > 0; i--)
    {
        for (j = 0; j < i; j++)
        {
            v_j = (void *)((char *)v + j*elementSize);
            v_j1 = (void *)((char *)v_j + elementSize);

            if ( (*compare)( v_j, v_j1) > 0)
                /* swap algorithm */
        }
    }
}`,
    question:
      "בהינתן הפונקציה הגנרית `GenBubbleSort` ומערך `arr` של מצביעים שבו כל תא מצביע למבנה מסוג `Student`, איזו מהפונקציות הבאות יכולה לשמש כפונקציית ההשוואה (`compare`) כדי למיין את המערך לפי שמות הסטודנטים? (השלמת הלוגיקה בתיבה [[1]] אינה חלק מהשאלה)",
    answers: [
      "`int my_compare_function( Student *s1, Student *s2) \n { return (strcmp((*s1).name, (*s2).name)); }`",
      "`int my_compare_function( Student *s1, Student *s2) \n { return (strcmp(s1->name, s2->name)); }`",
      "`int my_compare_function( Student **s1, Student **s2) \n { return (strcmp((*s1).name, (*s2).name)); }`",
      "`int my_compare_function( Student **s1, Student **s2) \n { return (strcmp((*s1)->name, (*s2)->name)); }`",
      "יותר מפונקציה אחת מבצעת הדרוש",
      "אף פונקציה מכאן לא מבצעת את הדרוש",
    ],
    correct: 3,
    hint: "הפונקציה `GenBubbleSort` מעבירה לפונקציית ההשוואה מצביעים *לאיברים* במערך. אם המערך הוא `Student **arr`, מהו הטיפוס של איבר בודד בו? ומהו הטיפוס של מצביע לאיבר כזה? הבנת רמות ההצבעה היא המפתח לכתיבת חתימת הפונקציה והגישה לנורא נכונה.",
    explanation:
      "המערך שעליו אנו עובדים הוא מערך של מצביעים לסטודנטים (`Student **`). כל איבר במערך זה הוא מצביע מסוג `Student *`. הפונקציה `GenBubbleSort` מעבירה לפונקציית ההשוואה מצביעים לאיברים אלו, ולכן הטיפוס הנכון שהפונקציה `my_cmp` צריכה לקבל הוא מצביע למצביע לסטודנט, כלומר `Student **`. עובדה זו פוסלת מיד את שתי האפשרויות הראשונות, המצפות לקבל פרמטרים מסוג `Student *`.\n\nכעת נבחן את שתי האפשרויות הנותרות, שתיהן עם חתימה נכונה. כדי לגשת לשדה `name`, עלינו לבצע `dereference` אחד על הפרמטר (`*s1`), מה שנותן לנו מצביע מסוג `Student *`. הדרך הנכונה לגשת לשדה של מבנה דרך מצביע היא באמצעות אופרטור החץ (`->`). לכן, הביטוי `(*s1)->name` הוא הביטוי הנכון.\n\nהאפשרות `return ( strcmp( (*s1).name, (*s2).name) );` אינה נכונה, מכיוון שהיא מנסה להשתמש באופרטור הנקודה (`.`) על מצביע (`*s1`), פעולה שתגרור שגיאת קומפילציה.",
  },
];
