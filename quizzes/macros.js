// עבר בדיקה
const quizData = [
  {
    code: `#define WHAT(x,y) (x*2) >= (y/2) ? (x/2) : (y*2)

void main() {
    float a;
    a = WHAT(1+4, 1+19);
    printf("%.1f", a);
}`,
    question: "מה יהיה הפלט של קטע הקוד הבא?",
    answers: ["`39.0`", "`2.5`", "`40.0`", "`2.0`"],
    correct: 0,
    hint: "פקודות מאקרו בשפת C מבצעות החלפת טקסט פשוטה. הביטויים המועברים כארגומנטים מוחלפים כפי שהם, ללא הוספת סוגריים באופן אוטומטי. חשוב לשים לב לסדר קדימויות האופרטורים לאחר ההצבה. למשל, אם מוגדר מאקרו `MUL(x)` כ־`x*3` והקריאה היא `MUL(1+2)`, הביטוי שיתקבל יהיה `1+2*3`, שערכו `7` ולא `9`. בנוסף, יש לזכור שפעולת חילוק בין שני מספרים שלמים תמיד תעגל את התוצאה כלפי מטה.",
    explanation:
      "הקוד מגדיר מאקרו בשם `WHAT` שמקבל שני ארגומנטים, `x` ו־`y`. בפונקציה `main`, המאקרו נקרא עם הערכים `1+4` עבור `x` ו־`1+19` עבור `y`. כיוון שמאקרו מבצע החלפת טקסט פשוטה, הביטוי שנוצר לאחר ההצבה הוא: `(1+4 * 2) >= (1+19 / 2) ? (1+4 / 2) : (1+19 * 2)`.\n\nבשל קדימות אופרטורים, פעולות הכפל והחילוק מתבצעות לפני החיבור. לכן, התנאי בביטוי הטרינארי הופך ל־`(1+8) >= (1+9)`, כלומר `9 >= 10`. תנאי זה הוא שקרי. כשהתנאי שקרי, הביטוי שמימין לנקודתיים (`:`) הוא זה שמחושב. ביטוי זה הוא `1+19 * 2`, שמתורגם ל־`1+38`, ותוצאתו היא `39`.\n\nהערך `39` (מספר שלם) מושם במשתנה `a` מסוג `float`, ולכן ערכו הופך ל־`39.0`. פקודת ההדפסה `printf` מציגה את המספר עם ספרה אחת אחרי הנקודה העשרונית, ולכן הפלט הסופי יהיה `39.0`.",
  },
  {
    code: `#define F(a,b) (a + b*a)
#define G(a,b,c,d) ((F(a,b)) < (F(c,d)) ? \\
                   (F(a,b)) : (F(c,d)))
void main() {
    printf("%d\\n", G(1+2, 2, 3, 2));
}`,
    question: "מה הפלט של התכנית הבאה?",
    answers: ["`7`", "`9`", "`4`", "התכנית לא עוברת קומפילציה"],
    correct: 0,
    hint: "זכרו שפקודות מאקרו מבצעות החלפת טקסט פשוטה. הביטוי `1+2` יוצב כפי שהוא במקום הפרמטר המתאים. לאחר ההצבה, יש לחשב את ערך הביטוי הסופי לפי סדר קדימויות האופרטורים המוגדר בשפת C.",
    explanation:
      "המאקרו `G` מבצע השוואה בין שתי קריאות למאקרו `F` ומחזיר את הערך הקטן מביניהם. ננתח כל קריאה בנפרד.\n\nהקריאה הראשונה היא `F(a,b)`, כאשר `a` מוחלף ב־`1+2` ו־`b` מוחלף ב־`2`. לאחר ההצבה במאקרו (`a + b*a`) נקבל את הביטוי `(1+2 + 2*1+2)`. בשל סדר קדימויות אופרטורים, פעולת הכפל מתבצעת לפני החיבור, ולכן הביטוי הוא `(1+2 + 2+2)`, שערכו הוא `7`.\n\nהקריאה השנייה היא `F(c,d)`, כאשר `c` מוחלף ב־`3` ו־`d` מוחלף ב־`2`. לאחר ההצבה נקבל `(3 + 2*3)`. גם כאן הכפל קודם לחיבור, והתוצאה היא `(3 + 6)`, שערכה הוא `9`.\n\nלבסוף, המאקרו `G` משווה בין שתי התוצאות (`7 < 9`). התנאי מתקיים, ולכן הביטוי כולו מחזיר את הערך הראשון, `7`.",
  },
  {
    code: `#define mac(a,b) a**b

int main() {

    int a[2], *b, *c;

    a[0] = 5;
    a[1] = 7;

    c = a;
    (*c)++;
    b = c + 1;

    printf("%d\\n", mac(a[0], b));
    return 0;
}`,
    question: "מהו הפלט של התכנית הבאה?",
    answers: ["`42`", "`35`", "`40`", "`49`", "כל התשובות האחרות אינן נכונות"],
    correct: 0,
    hint: "שימו לב שבביטוי `a**b` נעשה שימוש כפול בתו `*`. נסו לחשוב על המשמעות האפשרית של כל אחד מהם – ייתכן שהם מייצגים פעולות שונות.",
    explanation:
      "תחילה, ננתח את מצב המשתנים לפני הקריאה למאקרו. המערך `a` מאותחל לערכים `{5, 7}`. המצביע `c` מקבל את כתובת תחילת המערך, והפקודה `(*c)++` מגדילה את `a[0]` ל־`6`. לאחר מכן, המצביע `b` מקבל את הכתובת `c + 1`, ולכן הוא מצביע לאיבר השני במערך, `a[1]`, שערכו `7`.\n\nהקריאה למאקרו `mac(a[0], b)` גורמת להחלפת טקסט פשוטה. הביטוי `a**b` הופך ל־`a[0] * *b`. חשוב להבין את המשמעות הכפולה של התו `*` בהקשר זה: הכוכבית הראשונה (משמאל) היא אופרטור הכפל, בעוד הכוכבית השנייה היא אופרטור ה־dereference, הגוזר את הערך מהכתובת שהמצביע `b` מחזיק.\n\nלכן, הביטוי הסופי לחישוב הוא ערכו של `a[0]` (שהוא 6) כפול הערך שאליו `b` מצביע (שהוא `a[1]`, כלומר 7). התוצאה היא `6 * 7 = 42`.",
  },
  {
    code: `#define C(y) (y+2)
#define CALC(x,y) (C(x)*C(y))

int i = CALC( (C(1)), (C(2)) );`,
    question:
      "* טלי טוענת שניתן לוותר על הסוגריים בשורה האחרונה סביב `C(1)` ו־`C(2)` ולקבל את אותה התוצאה.\n\n* גלי טוענת שניתן לוותר על הסוגריים החיצוניים בהגדרת המאקרו `CALC` .\n\n* אילי טוען שהשורה האחרונה לא תעבור קומפילציה.\n\nמה מהבאים נכון?",
    answers: [
      "טלי צודקת, גלי טועה ואילי טועה",
      "גלי צודקת וטלי טועה ואילי טועה",
      "גלי ואחת מהבנות צודקים",
      "כולם טועים",
      "יתר התשובות אינן נכונות",
    ],
    correct: 0,
    hint: "מאקרו ב־C הוא החלפת טקסט פשוטה לפני שלב הקומפילציה. נסו 'להריץ' את ההחלפות בראש או על דף נייר צעד אחר צעד, פעם אחת עבור הקוד המקורי ופעם עבור כל אחת מהטענות.",
    explanation:
      "ננתח כל טענה:\n\nטענתו של אילי: הקוד המקורי תקין לחלוטין. הביטוי `CALC( (C(1)), (C(2)) )` יתפתח לביטוי `(C((3))*C((4)))`, אשר יתפתח ל־`(((3)+2)*((4)+2))`, שתוצאתו היא `(5*6)=30`. הקוד מתקמפל ועובד, לכן אילי טועה.\n\nטענתה של גלי: הסרת הסוגריים החיצוניים במאקרו `CALC` היא פרקטיקה מסוכנת. לדוגמה, אם נכתוב `100 / CALC(1,1)`, הביטוי יתפתח ל־`100 / C(1)*C(1)` ובשל קדימות אופרטורים יחושב כ־`(100/3)*3`, מה שנותן תוצאה שגויה. הסוגריים חיוניים להבטחת תקינות המאקרו, לכן גלי טועה.\n\nטענתה של טלי: הסרת הסוגריים הפנימיים מובילה לביטוי `CALC(C(1), C(2))`. זה יתפתח ל־`(C(C(1))*C(C(2)))` ולאחר מכן לביטוי `(((1+2)+2)*((2+2)+2))`, שגם תוצאתו `30`. במקרה הספציפי הזה, בזכות הסוגריים בהגדרת המאקרו `C`, התוצאה נשמרת. לכן טלי צודקת.",
  },
  {
    code: `#define WHAT(x,y) x*y+1

int main() {
    int a = 2, b = 3, c = 4;
    printf("%d\\n", WHAT(a+b, c));
    return 0;
}`,
    question: "מהו הפלט של התכנית הבאה?",
    answers: ["`15`", "`20`", "`17`", "`25`", "כל התשובות האחרות אינן נכונות"],
    correct: 0,
    hint: "פקודות מאקרו מבצעות החלפת טקסט בלבד. שימו לב היטב לסדר קדימויות האופרטורים לאחר שהביטוי `a+b` מחליף את `x` במאקרו.",
    explanation:
      "פקודות מאקרו בשפת C מבצעות החלפת טקסט פשוטה לפני שלב הקומפילציה. המאקרו `WHAT(x,y)` מוגדר כ־`x*y+1`.\n\nבפונקציה `main`, הקריאה למאקרו היא `WHAT(a+b, c)`. הקדם־מעבד (preprocessor) יחליף את `x` בביטוי `a+b` ואת `y` במשתנה `c` באופן מילולי. הביטוי שיישלח לקומפיילר לאחר ההחלפה הוא `a+b*c+1`.\n\nבשל סדר קדימויות האופרטורים ב־C, פעולת הכפל (`*`) תתבצע לפני פעולות החיבור (`+`). לכן, הביטוי יחושב כך: `a + (b*c) + 1`. לאחר הצבת הערכים (`a=2`, `b=3`, `c=4`), נקבל: `2 + (3*4) + 1`, ששווה ל־`2 + 12 + 1`, והתוצאה הסופית היא `15`.",
  },
  {
    code: `#define WHAT(x,y) (x*2) >= y ? (x/2) : (y*2)

void main() {
    float a;
    a = WHAT(WHAT(1 + 4, 1 + 5), 1 + 6);
    printf("%.0f", a);
}`,
    question: "מהו הפלט של התכנית הבאה?",
    answers: [
      "`13`",
      "`3`",
      "`14`",
      "`2`",
      "`12`",
      "אף תשובה מבין התשובות האחרות אינה נכונה",
    ],
    correct: 0,
    hint: "יש כאן קריאה מקוננת למאקרו. פתרו את הביטוי הפנימי, `WHAT(1+4, 1+5)`, קודם. זכרו שמאקרו הוא החלפת טקסט פשוטה ושסדר קדימויות האופרטורים קובע.",
    explanation:
      "יש לפתור את הביטוי שלב אחר שלב, מבפנים החוצה.\n\nתחילה נחשב את הביטוי הפנימי, `WHAT(1+4, 1+5)`. לאחר החלפת הטקסט במאקרו, הביטוי הופך ל־`(1+4 * 2) >= 1+5 ? (1+4 / 2) : (1+5 * 2)`. התנאי הוא `9 >= 6`, שהוא אמת. לכן, הביטוי מחזיר את החלק הראשון, `(1 + 4/2)`, שערכו `3`.\n\nכעת, הביטוי המלא הוא `WHAT(3, 1+6)`. לאחר החלפת טקסט, הביטוי הופך ל־`(3*2) >= 1+6 ? (3/2) : (1+6*2)`. התנאי כאן הוא `6 >= 7`, שהוא שקרי. לכן, הביטוי מחזיר את החלק השני, `(1+6*2)`. בשל קדימות אופרטורים, התוצאה היא `1+12`, כלומר `13`.\n\nהערך `13` יודפס למסך.",
  },
  {
    code: `#define PRINT(i, limit) i++ < limit ? \\
                    printf("1") : printf("0")

void main() {
    PRINT(0, 3);
    PRINT(3, 0);
}`,
    question: "מה תהיה התוצאה של ניסיון לקמפל ולהריץ את התכנית הבאה?",
    answers: [
      "כל התשובות האחרות אינן נכונות",
      "`10`",
      "`01`",
      "`11`",
      "`00`",
      "התוכנית תעוף בזמן ריצה",
    ],
    correct: 0,
    hint: "היזכרו מה המשמעות של האופרטור `++` ועל אילו סוגי ערכים, כמו משתנים או קבועים, ניתן להפעיל אותו.",
    explanation:
      "הקוד אינו עובר קומפילציה. הסיבה לכך היא שפעולת ה־`i++` היא למעשה קיצור של השמה (`i = i + 1`). בצד שמאל של כל פעולת השמה (`=`), חייב להופיע `lvalue` – ביטוי המייצג מקום בזיכרון שניתן להכניס אליו ערך חדש, כמו משתנה.\n\nכאשר המאקרו `PRINT(i, limit)` מופעל עם ערך ליטרלי `0` עבור `i` (כלומר, `PRINT(0, 3)`), הוא מתרחב לביטוי `0++`. הקומפיילר מפרש זאת כניסיון להציב ערך חדש לתוך הקבוע `0` (`0 = 0 + 1`), וזה לא אפשרי. לקבוע `0` אין מיקום זיכרון שניתן לשנותו, ולכן מתקבלת שגיאת קומפילציה: `lvalue required as increment operand`. כיוון שהקוד כלל לא מתקמפל, כל יתר התשובות המתארות פלט או שגיאת ריצה אינן נכונות.",
  },
  {
    code: `#define MAX2(A, B) (((A) > (B)) ? (A) : (B))
#define MAX3(A, B, C) (MAX2(MAX2(A, B), C))

int f() { return 10; }
int g() { return 5; }
int h() { return 0; }

void main() {
    printf("MAX=%d", MAX3(f(), g(), h()));
}`,
    question: "בהינתן קטע הקוד, איזו טענה נכונה לגבי מספר הקריאות לכל פונקציה?",
    answers: [
      "הפונקציה f נקראת 4 פעמים, הפונקציה g נקראת פעמיים והפונקציה h נקראת פעם אחת",
      "הפונקציה f נקראת 4 פעמים, הפונקציה g נקראת פעם אחת והפונקציה h נקראת פעם אחת",
      "הפונקציה f נקראת 4 פעמים, הפונקציה g נקראת פעמיים והפונקציה h נקראת פעמיים",
      "הפונקציה f נקראת 3 פעמים, הפונקציה g נקראת פעמיים והפונקציה h נקראת פעם אחת",
      "יתר התשובות אינן נכונות",
    ],
    correct: 0,
    hint: "זכרו שמאקרו מבצע החלפת טקסט פשוטה. כל ארגומנט שהועבר למאקרו (במקרה זה, קריאה לפונקציה) יוערך מחדש בכל פעם שהוא מופיע בגוף המאקרו המורחב. עקבו אחר ההרחבה צעד אחר צעד.",
    explanation:
      'הקריאה למאקרו `MAX3` מתרחבת לביטוי הטרינארי המקונן: `((MAX2(f(), g())) > (h())) ? (MAX2(f(), g())) : (h())`. בגלל החלפת הטקסט הפשוטה של מאקרו, הארגומנטים `f()`, `g()`, ו־`h()` יוערכו בכל פעם שהם מופיעים בביטוי המורחב.\n\nכדי להעריך את התנאי, `(MAX2(f(), g()) > h())`, נדרש תחילה לחשב את `MAX2(f(), g())`. ביטוי זה קורא ל־`f()` (פעם 1) ול־`g()` (פעם 1). מכיוון ש־`10 > 5`, הוא קורא ל־`f()` שוב (פעם 2) כדי להחזיר את הערך `10`. לאחר מכן, `h()` נקראת (פעם 1) לצורך ההשוואה `10 > 0`. התנאי הוא אמת. סה"כ עד כה: `f` נקראה פעמיים, `g` פעם אחת, `h` פעם אחת.\n\nמכיוון שהתנאי הוא אמת, הביטוי `MAX2(f(), g())` מחושב שוב במלואו כדי לקבוע את הערך המוחזר. הערכה שנייה זו קוראת ל־`f()` (פעם 3) ול־`g()` (פעם 2). שוב, התנאי `10 > 5` הוא אמת, ולכן `f()` נקראת פעם נוספת (פעם 4) כדי להחזיר את הערך הסופי.\n\nבסיכום, סך הקריאות הוא: `f` נקראה 4 פעמים, `g` נקראה פעמיים, ו־`h` נקראה פעם אחת.',
  },
  {
    code: `#define S(x) x*x
#define M(x,y) x*y

void g(int x, int y) {
    static int a = 2;
    int z = S(x+y);
    a += M(x+y,y+x);
    printf("%d %d ", a, z);
}

void main() {
    int x = 3, y = 5;
    g(x,y);
    g(y,x);
}`,
    question: "מה יהיה הפלט של קטע הקוד הבא?",
    answers: [
      "`33 23 52 23`",
      "`33 64 52 64`",
      "`66 23 130 23`",
      "`66 64 130 64`",
      "כל התשובות האחרות אינן נכונות",
    ],
    correct: 0,
    hint: "שימו לב לשלושה דברים: מאקרואים מבצעים החלפת טקסט פשוטה, סדר קדימויות האופרטורים קובע את סדר החישוב, והמילה השמורה `static` גורמת למשתנה לשמור על ערכו בין קריאות שונות לפונקציה.",
    explanation:
      "בקריאה הראשונה לפונקציה `g(3, 5)`, המשתנה הסטטי `a` מאותחל ל־2. חישוב `z` לפי המאקרו `S(x+y)` הופך לביטוי `3+5*3+5` (בשל החלפת טקסט וקדימות אופרטורים), שתוצאתו `23`. לאחר מכן, ל־`a` מתווסף הערך מהמאקרו `M`, שהופך לביטוי `3+5*5+3` ותוצאתו `31`. לכן, `a` הופך ל־`2 + 31 = 33`, והפלט הראשון הוא `33 23`.\n\nבקריאה השנייה לפונקציה, `g(5, 3)`, המשתנה הסטטי `a` אינו מאותחל מחדש ושומר על ערכו, כלומר `33`. חישוב `z` עם הערכים החדשים (`x=5, y=3`) נותן `5+3*5+3`, שזה שוב `23`. ל־`a` מתווספת התוצאה של `5+3*3+5`, שהיא `19`. ערכו הסופי של `a` מתעדכן ל־`33 + 19 = 52`. לכן, הפלט מהקריאה השנייה הוא `52 23`.",
  },
];
