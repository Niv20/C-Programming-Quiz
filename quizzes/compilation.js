// עבר בדיקה
const quizData = [
  {
    code: "",
    question:
      "כותבים תכנית המורכבת ממספר קבצי מקור (קבצי `c.`). פונקציה גלובלית בשם `someFunc` ממומשת במלואה בשני קבצים שונים. איזו מהטענות הבאות נכונה?",
    answers: [
      "שגיאת לינקר בכל מקרה",
      "שגיאת לינקר רק אם התוכן בשני המימושים שונה",
      "שגיאת לינקר רק אם ה־prototype בשני הקבצים שונה",
      "שגיאת קומפילציה בכל מקרה",
      "אף תשובה אינה נכונה",
    ],
    correct: 0,
    hint: "חשבו על ההבדל בין שלב הקומפילציה, שבו כל קובץ מקור מתורגם בנפרד לקובץ אובייקט, לבין שלב הקישור (linking), שבו כל קבצי האובייקט מאוחדים יחד לקובץ הרצה יחיד.",
    explanation:
      "במהלך בניית התוכנית, כל קובץ מקור עובר קומפילציה בנפרד. מבחינת הקומפיילר, כל אחד מהקבצים המכילים את `someFunc` הוא תקין בפני עצמו, ולכן לא תתרחש שגיאת קומפילציה.\n\nהבעיה מתעוררת בשלב הקישור (linking). תפקידו של הלינקר הוא לחבר את כל קבצי האובייקט שנוצרו בשלב הקומפילציה ולוודא שכל סמל גלובלי (כמו שם של פונקציה) מוגדר בדיוק פעם אחת. כלל זה ידוע בתור 'One Definition Rule'. כאשר הלינקר מזהה שהסמל `someFunc` מוגדר בשני קבצי אובייקט שונים, הוא אינו יודע באיזה מימוש לבחור ומנפיק שגיאת 'multiple definition'.\n\nחשוב להדגיש שהשגיאה תתרחש תמיד במצב זה, גם אם שני המימושים של הפונקציה זהים לחלוטין וגם אם ה־`prototype` שלהם תואם. עצם ההגדרה הכפולה של סמל גלובלי מהווה הפרה של כללי השפה.",
  },
  {
    code: "",
    question:
      "כותבים תוכנית המורכבת מהקבצים הבאים:\n`h.h`\t`c.c`\t`b.c`\t`a.c`\nהפונקציה `someFunc` מוגדרת (לא רק מוצהרת) בתוך `h.h`.\nרק הקובץ `a.c` מבצע `include#` לקובץ `h.h`, בעוד הקובץ `c.c` קורא לפונקציה `someFunc`.\nאיזו מהטענות הבאות נכונה?",
    answers: [
      "תהליך של קומפילציה בלבד לקובץ `c.c` ייכשל עם שגיאת קומפילציה",
      "תהליך של קומפילציה וקישור של כל הקבצים יחד ייכשל עם שגיאת לינקר",
      "תהליך של קומפילציה בלבד לקובץ `a.c` ייכשל עם שגיאת קומפילציה",
      'אם נוסיף `#include "h.h"` גם לקובץ `c.c`, התוכנית תעבור קומפילציה וקישור ללא כל שגיאה',
      "אף תשובה אינה נכונה",
    ],
    correct: 0,
    hint: "זכרו שכל קובץ מקור (`.c`) מקומפל בנפרד. כדי להשתמש בפונקציה, הקומפיילר חייב לראות הצהרה שלה קודם לכן. מה קורה כאשר קוראים לפונקציה בקובץ אחד, אך ההגדרה שלה נמצאת בקובץ כותר שכלל לא נטען אליו?",
    explanation:
      "התשובה הנכונה מתבססת על כך שבשפת C, חובה להצהיר על פונקציה לפני שמשתמשים בה. הקובץ `c.c` קורא לפונקציה `someFunc` אך אינו כולל את קובץ הכותר `h.h` שבו היא מוגדרת. לכן, כאשר הקומפיילר ינסה לקמפל את `c.c`, הוא ייתקל בקריאה לפונקציה שאינו מכיר ויפיק שגיאת קומפילציה. התהליך ייעצר עוד לפני שלב הקישור.\n\nשאר הטענות אינן נכונות. קימפול של כל הקבצים יחד ייכשל בשלב הקומפילציה של `c.c`, ולכן לא נגיע כלל לשגיאת לינקר. קימפול של `a.c` לבדו יצליח, כיוון שהוא כולל את `h.h` והקוד בו חוקי. לבסוף, אם היינו מוסיפים את קובץ הכותר `h.h` גם ל־`c.c`, היינו פותרים את שגיאת הקומפילציה אך יוצרים שגיאת לינקר מסוג 'multiple definition', כיוון שהפונקציה `someFunc` הייתה מוגדרת גם בקובץ האובייקט של `a.c` וגם בזה של `c.c`.",
  },
  {
    code: `int myIntCmp(void*, void*);

void main() {
    int arr[10] = { 1,2,3,5,3,4,6,2,7,8 };
    qsort(arr, 10, sizeof(int), myIntCmp);
}`,
    question:
      "* טלי: כעת התכנית עוברת קומפילציה, אך אלמלא כתבנו את ה־`prototype` של `myIntCmp` היא לא היתה מתקמפלת.\n* שרון: הפונקציה `myIntCmp` נקראת מתוך `qsort`.\n* סיגל: אם הפונקציה `myIntCmp` לא תוגדר בשום קובץ, זו תהיה שגיאת לינקר.\n\nאיזו מהאפשרויות הבאות היא הנכונה?",
    answers: [
      "כולן צודקות",
      "רק סיגל צודקת, טלי ושרון טועות",
      "רק שרון צודקת, טלי וסיגל טועות",
      "סיגל טועה ושרון וטלי צודקות",
      "שרון צודקת וסיגל וטלי טועות",
      "אף תשובה מהתשובות האחרות אינה נכונה",
    ],
    correct: 0,
    hint: "חשבו על שלושה היבטים נפרדים: מה דורש הקומפיילר כדי לאמת קריאה לפונקציה, כיצד עובדת פונקציית ספריה כמו `qsort` המקבלת פונקציה אחרת כארגומנט, ומהו תפקידו של הלינקר לאחר שהקומפילציה הסתיימה בהצלחה.",
    explanation:
      "התשובה הנכונה היא שכל הטענות נכונות. נפרט מדוע כל אחת מהן מדויקת:\n\nטענתה של טלי נכונה. ההצהרה (prototype) על הפונקציה `myIntCmp` חיונית כדי שהקומפיילר יכיר את חתימתה ויאפשר להעביר אותה כארגומנט לפונקציה `qsort`. ללא הצהרה זו, הקומפיילר היה מדווח על שימוש במזהה לא מוכר, מה שהיה גורם לשגיאת קומפילציה.\n\nטענתו של שרון נכונה. הפונקציה `qsort` היא פונקציית מיון גנרית. כדי לדעת כיצד להשוות בין שני איברים מהסוג שהועבר אליה, היא משתמשת בפונקציית השוואה חיצונית המועברת אליה כארגומנט (callback function). לכן, במהלך ריצת המיון, `qsort` תקרא לפונקציה `myIntCmp` פעמים רבות.\n\nטענתה של סיגל נכונה. ישנו הבדל בין הצהרה על פונקציה לבין הגדרתה (המימוש שלה). הקוד מצהיר על `myIntCmp` אך אינו מממש אותה. הקומפיילר מסתפק בהצהרה כדי לייצר קובץ אובייקט, אך הלינקר, שתפקידו לחבר את כל חלקי הקוד, לא ימצא את המימוש של `myIntCmp` ויפיק שגיאת 'undefined reference'.",
  },
  {
    code: `int *f() {
    int i;
    return &i;
}

int *g(int i) {
    return i;
}`,
    question:
      "* טלי טוענת: הפונקציה f לא עוברת קומפילציה אבל g כן.\n* גלי טוענת: שתי הפונקציות עוברות קומפילציה אך יש בשתיהן באג זמן ריצה.\n* אלי טוען: שתי הפונקציות עוברות קומפילציה אך יש רק ב־f באג זמן ריצה.\n\nמה מהבאים נכון?",
    answers: [
      "רק גלי צודקת",
      "רק אלי צודק",
      "רק טלי צודקת",
      "כולם טועים",
      "יתר התשובות אינן נכונות",
    ],
    correct: 3,
    hint: "בשתי הפונקציות קיימת בעייתיות הקשורה להחזרת ערך ממשתנה מקומי. חישבו מה ההבדל בין החזרת כתובת של משתנה מקומי, לבין החזרת ערך מסוג שונה ממה שהפונקציה הצהירה עליו.",
    explanation:
      "קל לראות שהפונקציה `g` לא תעבור קומפילציה. היא מוצהרת כמחזירה ערך מסוג `int*`, אך בפועל מנסה להחזיר ערך מסוג `int`. זוהי שגיאת טיפוסים (type error) שהקומפיילר יזהה וימנע את השלמת הקומפילציה. מאחר ש־`g` לא מתקמפלת, אפשר לומר כבר שגלי ואלי טועים.\n\nמה לגבי הפונקציה `f`? אנחנו רואים שהיא מחזירה כתובת של משתנה מקומי (`i`). משתנה זה יושב על מחסנית הקריאות של הפונקציה, והזיכרון שלו משתחרר מיד עם סיום ריצתה. כזכור, שימוש במצביע הזה מוביל להתנהגות בלתי צפויה. אז, אולי, היינו יכולים לחשוב שהיא לא תעבור קומפילציה. אבל דווקא היא כן עוברת קומפילציה, כי מבחינת כללי התחביר והטיפוסים של שפת C, אין כאן שגיאה (היא מחזירה בדיוק את הטיפוס שמופיע בחתימה שלה, ואין בה שגיאות תחביר אחרות). זה שהיא מחזירה מצביע לא חוקי, זה כבר בעיה לוגית של התוכנית שלנו, אבל מבחינת הקומפיילר - הפונקציה בסדר גמור. בקיצור, גם טלי טועה, ולכן התשובה הנכונה היא שכולם טועים.\n\n",
  },
  {
    code: "",
    question:
      "* טלי טוענת: אם קוראים לפונקציה לפני המימוש שלה וגם לא כותבים את החתימה שלה - אז תהייה שגיאת לינקר.\n* גלי טוענת: אם כותבים מאקרו בקובץ  source אחד, ניתן להשתמש בו בכל קובץ אחר.\n* אלי טוען: משתנה גלובלי חייב להיות מוכרז בקובץ header.\n\nמה מהבאים נכון?",
    answers: [
      "כולם טועים",
      "טלי צודקת, גלי טועה ואלי טועה",
      "גלי צודקת וטלי ואלי טועה",
      "אלי ואחת מהבנות צודקים",
      "יתר התשובות אינן נכונות",
    ],
    correct: 0,
    hint: "חשבו על תהליך בניית התוכנית בשלבים: preprocessor ואז compilation ולבסוף linker. שייכו כל טענה לשלב הנכון בתהליך ובדקו את נכונותה בהקשר זה.",
    explanation:
      "\n\nטלי טועה מכיוון שהבעיה שהיא מתארת מתרחשת בשלב הקומפילציה, לא בשלב הקישור. בשפת C, כאשר קוראים לפונקציה שטרם הוצהרה או הוגדרה, הקומפיילר אינו מכיר את חתימתה ולכן יפיק שגיאת קומפילציה. התהליך כלל לא יגיע לשלב הלינקר.\n\nגלי טועה מפני שמאקרואים המוגדרים באמצעות `#define` עוברים הרחבה על ידי הקדם־מעבד (preprocessor) בכל קובץ בנפרד. מאקרו שמוגדר בקובץ `a.c` אינו מוכר כלל בקובץ `b.c`. הדרך המקובלת לשתף מאקרואים היא להגדירם בקובץ header ולכלול אותו בכל קבצי המקור הרלוונטיים.\n\nאלי טועה מפני שהצהרה על משתנה גלובלי בקובץ header אינה חובה. אם המשתנה הגלובלי נמצא בשימוש רק בקובץ המקור בו הוא הוגדר, אין כל צורך להצהיר עליו במקום אחר.",
  },
  {
    code: "",
    question:
      "תוכנית מחולקת לשלושה קבצי מקור:\n`c.c`\t`b.c`\t`a.c`.\n\nכל השלושה מבצעים `include#` לקובץ `h.h` שמכיל את כל הצהרות הפונקציות בתוכנית, ובנוסף גם את המימוש המלא של אחת מהפונקציות.\nאיזו מהטענות הבאות נכונה?",
    answers: [
      "התכנית לא תעבור link",
      "כל התשובות האחרות אינן נכונות",
      "התכנית תעבור link בכל מקרה",
      "התכנית לא תתקמפל",
      "התכנית לא תעבור link רק אם ישנה קריאה לפונקציה",
    ],
    correct: 0,
    hint: "חשבו מה קורה כאשר קובץ כותר המכיל מימוש שלם של פונקציה (ולא רק הצהרה) נכלל במספר קבצי מקור שונים. מה יקרה בשלב הקומפילציה של כל קובץ בנפרד, ומה יקרה כאשר הלינקר ינסה לאחד את כולם?",
    explanation:
      "התשובה הנכונה היא שהתוכנית לא תעבור link. הסיבה העיקרית היא שקובץ header מכיל את המימוש המלא של פונקציה. בכל פעם שקובץ מקור (`.c`) כולל אותו, נוצר עותק נפרד של מימוש הפונקציה בקובץ האובייקט שלו.\n\nבשלב הקישור, הלינקר מזהה שיש מספר הגדרות (מימושים) לאותה פונקציה בין קבצי האובייקט השונים, מה שמפר את כלל 'הגדרה אחת' (One Definition Rule) וגורם לשגיאה מסוג 'multiple definition'.\n\nחשוב להדגיש ששגיאה זו אינה תלויה בקיומה של קריאה לפונקציה בקוד. היא נובעת מעצם קיומן של הגדרות מרובות לאותו סמל שהלינקר מזהה, גם אם אף אחת מההגדרות אינה נדרשת בפועל על ידי קריאה.",
  },
  {
    code: `void main() {

    #define X 17

    #if !X
        printf("Computer");
        #define X 0
    #else
        printf("Science");
    #endif
}
`,
    question: "מה יהיה הפלט של קטע הקוד הבא?",
    answers: [
      "`Science`",
      "התוכנית אינה מתקמפלת",
      "`Computer`",
      "תתקבל שגיאה בזמן ריצה",
      "כל התשובות האחרות אינן נכונות",
    ],
    correct: 0,
    hint: "זכרו שהוראות קדם־מעבד (preprocessor) כמו `#if` ו־`#define` מעובדות לפני שהקומפיילר בכלל רואה את הקוד. כיצד הקדם־מעבד מפרש ערכים שאינם אפס בתוך תנאי בוליאני?",
    explanation:
      "הקוד משתמש בהוראות קדם־מעבד (preprocessor) מותנות, אשר רצות לפני שלב הקומפילציה עצמו. בתחילה, המאקרו `X` מוגדר עם הערך 17.\n\nלאחר מכן, הקדם־מעבד בודק את התנאי `#if !X`. מכיוון ש־`X` הוא 17, והקדם־מעבד מתייחס לכל ערך שאינו 0 כאמת (true), הביטוי `!X` (כלומר `!17`) מקבל את הערך שקר (false).\n\nכתוצאה מכך, בלוק הקוד שנמצא תחת התנאי `#if`, כולל ההדפסה של `Computer`, נמחק מהקוד ולא יגיע לקומפיילר כלל. הקוד היחיד שיישאר מהבלוק המותנה הוא זה שנמצא תחת `#else`, ולכן התוכנית שתתקמפל תכיל רק את הפקודה להדפיס `Science`.",
  },
  {
    code: `#define X 17

#ifndef X
    printf("Hello");
#else
    printf("World");
#endif

void main() {}`,
    question: "מה תהיה התוצאה של הרצת קטע הקוד הבא?",
    answers: [
      "התוכנית לא עוברת קומפילציה",
      "`Hello`",
      "התוכנית תעוף בזמן ריצה",
      "`World`",
      "כל התשובות האחרות אינן נכונות",
    ],
    correct: 0,
    hint: "שימו לב לאות `n` בהוראה `#ifndef` — היא מייצגת את המילה *not*, כלומר: אם לא מוגדר. במקרה של התרגיל הזה, האם `X` מוגדר או לא? האם הקוד שנשאר אחרי עיבוד הקדם־מעבד, תקני מבחינת מבנה?",
    explanation:
      "הקוד לא יעבור קומפילציה. ההוראה `#ifndef X` פירושה: 'אם X לא מוגדר'. כאן `X` מוגדר באמצעות `#define X 17`, ולכן התנאי לא מתקיים — והקדם־מעבד בוחר בבלוק של `#else`, כלומר, הוא משאיר את הדפסת המחרוזת `'world'`. אינטואיטיבית היינו רוצים לומר שזה מה שיודפס, אבל יש כאן קאצ'. הקריאה ל־`printf` נמצאת מחוץ לגוף של פונקציה, וכידוע כל פקודה חייבת להיות בתוך פונקציה כלשהי. אז מכיוון שמדובר כאן על שגיאה תחבירית, התוכנית אפילו לא תתקמפל.",
  },
  {
    code: `#define PI 3.14

#include "module1.h"

void main() {
    for (int i = 5; i > 0; i--)
        printf("Hello");
}`,
    question:
      "נתונה התוכנית הבאה. ניתן להניח שקובץ `module1.h` קיים וה־`include` מתבצע בהצלחה.\nאיזו מהטענות הבאות נכונה ביותר?",
    answers: [
      "התוכנית לא תעבור קומפילציה אם ישנה הגדרת `#define PI` בקובץ `module1.h` ששונה מההגדרה בתוכנית הראשית",
      "התוכנית תעבור קומפילציה ללא תלות בתוכן הקובץ `module1.h` ותדפיס `Hello` 5 פעמים",
      "התוכנית תעבור קומפילציה ללא תלות בתוכן הקובץ `module1.h` ותדפיס `Hello` 4 פעמים",
      "התוכנית תעבור קומפילציה אך נקבל שגיאת זמן ריצה",
      "יותר מתשובה אחת נכונה",
      "אף תשובה אינה נכונה",
    ],
    correct: 0,
    hint: "חשבו על השלב שבו הוראות כמו `#define` ו־`#include` מטופלות. מה קורה אם הקדם־מעבד (preprocessor) נתקל בהגדרה כפולה של אותו macro עם ערכים שונים?",
    explanation:
      "התשובה הנכונה היא שהתוכנית לא תעבור קומפילציה אם קיימת הגדרה סותרת בקובץ header. הקדם־מעבד של שפת C אינו מאפשר להגדיר מאקרו עם שם מסוים יותר מפעם אחת עם ערכים שונים. אם הקובץ `module1.h` מכיל הגדרה כמו `#define PI 3.14159`, והקוד הראשי מגדיר `#define PI 3.14`, הקדם־מעבד יזהה זאת כהגדרה מחדש (redeclaration) ויפיק שגיאה שתמנע את המשך הקומפילציה.\n\nכדי לשנות ערך של מאקרו שכבר הוגדר, יש לבטל תחילה את ההגדרה הקיימת באמצעות הוראת `#undef`, ורק לאחר מכן להגדיר את המאקרו מחדש עם הערך החדש.",
  },
];
