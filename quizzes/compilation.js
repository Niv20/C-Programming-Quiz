const quizData = [
  {
    code: "",
    question:
      "כותבים תכנית המורכבת ממספר קבצי מקור (קבצי `.c`). פונקציה גלובלית בשם `someFunc` מוגדרת (כלומר, ממומשת במלואה) בשני קבצים שונים. איזו מהטענות הבאות נכונה?",
    answers: [
      "שגיאת לינקר בכל מקרה",
      "שגיאת לינקר רק אם התוכן בשני המימושים שונה",
      "שגיאת לינקר רק אם ה־prototype בשני הקבצים שונה",
      "שגיאת קומפילציה בכל מקרה",
      "אף תשובה אינה נכונה",
    ],
    correct: 0,
    hint: "חשבו על ההבדל בין שלב הקומפילציה, שבו כל קובץ מקור מתורגם בנפרד לקובץ אובייקט, לבין שלב הקישור (linking), שבו כל קבצי האובייקט מאוחדים יחד לקובץ הרצה יחיד.",
    explanation:
      "במהלך בניית התוכנית, כל קובץ מקור עובר קומפילציה בנפרד. מבחינת הקומפיילר, כל אחד מהקבצים המכילים את `someFunc` הוא תקין בפני עצמו, ולכן לא תתרחש שגיאת קומפילציה.\n\nהבעיה מתעוררת בשלב הקישור (linking). תפקידו של הלינקר הוא לחבר את כל קבצי האובייקט שנוצרו בשלב הקומפילציה ולוודא שכל סמל גלובלי (כמו שם של פונקציה) מוגדר בדיוק פעם אחת. כלל זה ידוע בתור 'One Definition Rule'. כאשר הלינקר מזהה שהסמל `someFunc` מוגדר בשני קבצי אובייקט שונים, הוא אינו יודע באיזה מימוש לבחור ומנפיק שגיאת 'multiple definition'.\n\nחשוב להדגיש שהשגיאה תתרחש תמיד במצב זה, גם אם שני המימושים של הפונקציה זהים לחלוטין וגם אם ה־`prototype` שלהם תואם. עצם ההגדרה הכפולה של סמל גלובלי מהווה הפרה של כללי השפה.",
  },
  {
    code: "",
    question:
      "כותבים תוכנית המורכבת משלושה קבצי מקור: `a.c`, `b.c`, ו־`c.c`, וקובץ כותר `h.h`. הפונקציה `someFunc` מוגדרת במלואה (לא רק מוצהרת) בתוך `h.h`. רק הקובץ `a.c` מבצע `#include` לקובץ `h.h`, בעוד הקובץ `c.c` קורא לפונקציה `someFunc`. איזו מהטענות הבאות נכונה?",
    answers: [
      "תהליך של קומפילציה בלבד לקובץ `c.c` ייכשל עם שגיאת קומפילציה",
      "תהליך של קומפילציה וקישור של כל הקבצים יחד ייכשל עם שגיאת לינקר",
      "תהליך של קומפילציה בלבד לקובץ `a.c` ייכשל עם שגיאת קומפילציה",
      'אם נוסיף `#include "h.h"` גם לקובץ `c.c`, התוכנית תעבור קומפילציה וקישור ללא כל שגיאה',
      "אף תשובה אינה נכונה",
    ],
    correct: 0,
    hint: "זכרו שכל קובץ מקור (`.c`) מקומפל בנפרד. כדי להשתמש בפונקציה, הקומפיילר חייב לראות הצהרה שלה קודם לכן. מה קורה כאשר קוראים לפונקציה בקובץ אחד, אך ההגדרה שלה נמצאת בקובץ כותר שכלל לא נטען אליו?",
    explanation:
      "התשובה הנכונה מתבססת על כך שבשפת־C, חובה להצהיר על פונקציה לפני שמשתמשים בה. הקובץ `c.c` קורא לפונקציה `someFunc` אך אינו כולל את קובץ הכותר `h.h` שבו היא מוגדרת. לכן, כאשר הקומפיילר ינסה לקמפל את `c.c`, הוא ייתקל בקריאה לפונקציה שאינו מכיר ויפיק שגיאת קומפילציה. התהליך ייעצר עוד לפני שלב הקישור.\n\nשאר הטענות אינן נכונות. קימפול של כל הקבצים יחד ייכשל בשלב הקומפילציה של `c.c`, ולכן לא נגיע כלל לשגיאת לינקר. קימפול של `a.c` לבדו יצליח, כיוון שהוא כולל את `h.h` והקוד בו חוקי. לבסוף, אם היינו מוסיפים את קובץ הכותר `h.h` גם ל־`c.c`, היינו פותרים את שגיאת הקומפילציה אך יוצרים שגיאת לינקר מסוג 'multiple definition', כיוון שהפונקציה `someFunc` הייתה מוגדרת גם בקובץ האובייקט של `a.c` וגם בזה של `c.c`.",
  },
  {
    code: `int myIntCmp(void*, void*);

int main()
{
    int arr[10] = { 1,2,3,5,3,4,6,2,7,8 };
    qsort(arr, 10, sizeof(int), myIntCmp);
    return 0;
}`,
    question:
      "בהינתן קטע הקוד והטענות הבאות:\n\n* טלי: כעת התכנית עוברת קומפילציה, אך אלמלא כתבנו את ה־`prototype` של `myIntCmp` היא לא היתה מתקמפלת.\n* שרון: בעצם הקריאה ל־`qsort`, הפונקציה `myIntCmp` תתבצע מתוך `qsort`.\n* סיגל: אם הפונקציה `myIntCmp` לא תוגדר בשום קובץ, זו תהיה שגיאת לינקר.\n\nאיזו מהאפשרויות הבאות היא הנכונה?",
    answers: [
      "כולן צודקות",
      "רק סיגל צודקת, טלי ושרון טועות",
      "רק שרון צודקת, טלי וסיגל טועות",
      "סיגל טועה ושרון וטלי צודקות",
      "שרון צודקת וסיגל וטלי טועות",
      "אף תשובה מהתשובות האחרות אינה נכונה",
    ],
    correct: 0,
    hint: "חשבו על שלושה היבטים נפרדים: מה דורש הקומפיילר כדי לאמת קריאה לפונקציה, כיצד עובדת פונקציית ספריה כמו `qsort` המקבלת פונקציה אחרת כארגומנט, ומהו תפקידו של הלינקר לאחר שהקומפילציה הסתיימה בהצלחה.",
    explanation:
      "התשובה הנכונה היא שכל הטענות נכונות. נפרט מדוע כל אחת מהן מדויקת:\n\nטענתה של טלי נכונה. ההצהרה (prototype) על הפונקציה `myIntCmp` חיונית כדי שהקומפיילר יכיר את חתימתה ויאפשר להעביר אותה כארגומנט לפונקציה `qsort`. ללא הצהרה זו, הקומפיילר היה מדווח על שימוש במזהה לא מוכר, מה שהיה גורם לשגיאת קומפילציה.\n\nטענתו של שרון נכונה. הפונקציה `qsort` היא פונקציית מיון גנרית. כדי לדעת כיצד להשוות בין שני איברים מהסוג שהועבר אליה, היא משתמשת בפונקציית השוואה חיצונית המועברת אליה כארגומנט (callback function). לכן, במהלך ריצת המיון, `qsort` תקרא לפונקציה `myIntCmp` פעמים רבות.\n\nטענתה של סיגל נכונה. ישנו הבדל בין הצהרה על פונקציה לבין הגדרתה (המימוש שלה). הקוד מצהיר על `myIntCmp` אך אינו מממש אותה. הקומפיילר מסתפק בהצהרה כדי לייצר קובץ אובייקט, אך הלינקר, שתפקידו לחבר את כל חלקי הקוד, לא ימצא את המימוש של `myIntCmp` ויפיק שגיאת 'undefined reference'.",
  },
  {
    code: `int *f()
{
    int i;
    return &i;
}

int *g(int i)
{
    return i;
}`,
    question:
      "בהינתן הפונקציות הבאות והטענות שאחריהן:\n\n* טלי טוענת: הפונקציה f לא עוברת קומפילציה אבל g כן.\n* גלי טוענת: שתי הפונקציות עוברות קומפילציה אך יש בשתיהן באג זמן ריצה.\n* אלי טוען: שתי הפונקציות עוברות קומפילציה אך יש רק ב־f באג זמן ריצה.\n\nמה מהבאים נכון?",
    answers: [
      "רק גלי צודקת",
      "רק אלי צודק",
      "רק טלי צודקת",
      "כולם טועים",
      "יתר התשובות אינן נכונות",
    ],
    correct: 3,
    hint: "בשתי הפונקציות קיימת בעייתיות הקשורה להחזרת ערך ממשתנה מקומי. חישבו מה ההבדל בין החזרת כתובת של משתנה מקומי, לבין החזרת ערך מסוג שונה ממה שהפונקציה הצהירה עליו.",
    explanation:
      "כל הטענות שהועלו אינן נכונות. נסביר את הבעיות בכל אחת מהפונקציות:\n\nהפונקציה `f` אכן עוברת קומפילציה, אך רוב הקומפיילרים המודרניים ינפיקו אזהרה חמורה. הפונקציה מחזירה כתובת של משתנה מקומי (`i`). משתנה זה יושב על מחסנית הקריאות של הפונקציה, והזיכרון שלו משתחרר מיד עם סיום ריצתה. שימוש במצביע המוחזר יוביל להתנהגות בלתי צפויה (Undefined Behavior) בזמן ריצה.\n\nהפונקציה `g`, לעומת זאת, כלל לא תעבור קומפילציה. היא מוצהרת כמחזירה ערך מסוג מצביע לאינטגר (`int*`), אך בפועל מנסה להחזיר ערך מסוג אינטגר (`int`). זוהי שגיאת טיפוסים (type error) שהקומפיילר יזהה וימנע את השלמת הקומפילציה. מאחר ש־`g` לא מתקמפלת, כל טענה הגורסת שהיא עוברת קומפילציה היא שגויה מיסודה.",
  },
  {
    code: "",
    question:
      "בהנחה שבקובץ מקור מסוים, קריאה לפונקציה מופיעה לפני המימוש שלה, ובהינתן הטענות הבאות:\n\n* טלי טוענת: אם שוכחים לכתוב prototype של פונקציה וקוראים לה, אז הלינקר לא ימצא אותה.\n* גלי טוענת: אם כותבים מאקרו מקורי בקובץ source אחד, ניתן להשתמש בו בקובץ אחר.\n* אלי טוען: משתנה גלובלי חייב להיות מוכרז בקובץ header תמיד.\n\nמה מהבאים נכון?",
    answers: [
      "כולם טועים",
      "טלי צודקת, גלי טועה ואלי טועה",
      "גלי צודקת וטלי ואלי טועה",
      "אלי ואחת מהבנות צודקים",
      "יתר התשובות אינן נכונות",
    ],
    correct: 0,
    hint: "חשבו על תהליך בניית התוכנית בשלבים: קדם־עיבוד (macros), קומפילציה (declarations), וקישור (definitions). שייכו כל טענה לשלב הנכון בתהליך ובדקו את נכונותה בהקשר זה.",
    explanation:
      "כל שלוש הטענות אינן נכונות, וכל אחת מתייחסת לחלק אחר בתהליך בניית התוכנית.\n\nטלי טועה מכיוון שהבעיה שהיא מתארת מתרחשת בשלב הקומפילציה, לא בשלב הקישור. בשפת־C מודרנית, כאשר קוראים לפונקציה שטרם הוצהרה או הוגדרה, הקומפיילר אינו מכיר את חתימתה ולכן יפיק שגיאת קומפילציה. התהליך כלל לא יגיע לשלב הלינקר.\n\nגלי טועה מפני שמאקרואים המוגדרים באמצעות `#define` עוברים הרחבה על ידי הקדם־מעבד (preprocessor) בכל קובץ בנפרד. מאקרו שמוגדר בקובץ `a.c` אינו מוכר כלל בקובץ `b.c`. הדרך המקובלת לשתף מאקרואים היא להגדירם בקובץ כותר (`header`) ולכלול אותו בכל קבצי המקור הרלוונטיים.\n\nאלי טועה מפני שהצהרה על משתנה גלובלי בקובץ כותר אינה חובה תמיד. אם המשתנה הגלובלי נמצא בשימוש רק בקובץ המקור בו הוא הוגדר, אין כל צורך להצהיר עליו במקום אחר. אם רוצים לשתף אותו בין קבצים, מומלץ להצהיר עליו עם המילה `extern` בקובץ כותר, אך זוהי מוסכמה ופרקטיקה טובה, לא חוק מחייב.",
  },
  {
    code: "",
    question:
      "תוכנית מחולקת לשלושה קבצי מקור: `a.c`, `b.c`, ו־`c.c`. כל השלושה מבצעים `#include` לקובץ הכותר `h.h`. קובץ זה מכיל את כל הצהרות הפונקציות בתוכנית, ובנוסף, גם את המימוש המלא של אחת מהפונקציות. איזו מהטענות הבאות נכונה?",
    answers: [
      "התכנית לא תעבור link",
      "כל התשובות האחרות אינן נכונות",
      "התכנית תעבור link בכל מקרה",
      "התכנית לא תתקמפל",
      "התכנית לא תעבור link רק אם ישנה קריאה לפונקציה",
    ],
    correct: 3,
    hint: "חשבו מה קורה כאשר קובץ כותר המכיל מימוש שלם של פונקציה (ולא רק הצהרה) נכלל במספר קבצי מקור שונים. מה יקרה בשלב הקומפילציה של כל קובץ בנפרד, ומה יקרה כאשר הלינקר ינסה לאחד את כולם?",
    explanation:
      "התשובה הנכונה היא שהתוכנית לא תעבור link. הסיבה העיקרית היא שקובץ הכותר (`h.h`) מכיל את המימוש המלא של פונקציה. בכל פעם שקובץ מקור (`.c`) כולל אותו, נוצר עותק נפרד של מימוש הפונקציה בקובץ האובייקט שלו.\n\nבשלב הקישור, הלינקר מזהה שיש מספר הגדרות (מימושים) לאותה פונקציה בין קבצי האובייקט השונים, מה שמפר את כלל 'הגדרה אחת' (One Definition Rule) וגורם לשגיאה מסוג 'multiple definition'.\n\nחשוב להדגיש ששגיאה זו אינה תלויה בקיומה של קריאה לפונקציה בקוד. היא נובעת מעצם קיומן של הגדרות מרובות לאותו סמל שהלינקר מזהה, גם אם אף אחת מההגדרות אינה נדרשת בפועל על ידי קריאה.",
  },
  {
    code: `#define X 3
#if !X
    printf("Computer");
    #define X 0
#else
    printf("Science");
#endif

void main()
{
}`,
    question: "מה יהיה הפלט של קטע הקוד הבא?",
    answers: [
      "`Science`",
      "התוכנית אינה מתקמפלת",
      "`Computer`",
      "תתקבל שגיאה בזמן ריצה",
      "כל התשובות האחרות אינן נכונות",
    ],
    correct: 0,
    hint: "זכרו שהוראות קדם־מעבד (preprocessor) כמו `#if` ו־`#define` מעובדות לפני שהקומפיילר בכלל רואה את הקוד. כיצד הקדם־מעבד מפרש ערכים שאינם אפס בתוך תנאי בוליאני?",
    explanation:
      "הקוד משתמש בהוראות קדם־מעבד (preprocessor) מותנות, אשר רצות לפני שלב הקומפילציה עצמו. בתחילה, המאקרו `X` מוגדר עם הערך 3.\n\nלאחר מכן, הקדם־מעבד בודק את התנאי `#if !X`. מכיוון ש־`X` הוא 3, והקדם־מעבד מתייחס לכל ערך שאינו 0 כאמת (true), הביטוי `!X` (כלומר `!3`) מקבל את הערך שקר (false).\n\nכתוצאה מכך, בלוק הקוד שנמצא תחת התנאי `#if`, כולל ההדפסה של `Computer`, נמחק מהקוד ולא יגיע לקומפיילר כלל. הקוד היחיד שיישאר מהבלוק המותנה הוא זה שנמצא תחת `#else`, ולכן התוכנית שתתקמפל תכיל רק את הפקודה להדפיס `Science`.",
  },
  {
    code: `#define X 3
#if !X
    printf("Hello");
#else
    printf("World");
#endif

void main()
{
    return;
}`,
    question: "מה תהיה התוצאה של הרצת קטע הקוד הבא?",
    answers: [
      "התוכנית לא עוברת קומפילציה",
      "`Hello`",
      "התוכנית תעוף בזמן ריצה",
      "`World`",
      "כל התשובות האחרות אינן נכונות",
    ],
    correct: 0,
    hint: "שימו לב שהוראות הקדם־מעבד ממוקמות מחוץ לפונקציה. לאחר שהקדם־מעבד יסיים את עבודתו ויבחר איזה קטע קוד להשאיר, חישבו על החוקיות של מבנה הקוד שנותר מבחינת הקומפיילר.",
    explanation:
      "הקוד לא יעבור קומפילציה. ראשית, הקדם־מעבד (preprocessor) מעבד את ההוראות המותנות. התנאי `#if !X` מתורגם ל־`#if !3` מכיוון ש־`X` מוגדר כ־3. במונחי הקדם־מעבד, 3 נחשב לאמת, ולכן `!3` נחשב לשקר. כתוצאה מכך, בלוק הקוד שתחת `#if` נמחק, ורק הקוד שתחת `#else` נשאר.\n\nהקוד שמועבר לקומפיילר מכיל את פקודת ההדפסה מחוץ לפונקציה כלשהי. בשפת־C, כל הפקודות הביצועיות (כמו קריאה ל־`printf`) חייבות להיות ממוקמות בתוך גוף של פונקציה. מאחר שהכלל הזה מופר, הקומפיילר יפיק שגיאת קומפילציה.",
  },
  {
    code: `#define PI 3.14

int main()
{
    for (int i = 5; i > 0; i--)
        printf("Hello");
    
    return 0;
}`,
    question:
      "נתונה התוכנית הבאה. ניתן להניח שקובץ `module1.h` קיים וה־`include` מתבצע בהצלחה.\nאיזו מהטענות הבאות נכונה ביותר?",
    answers: [
      "התוכנית לא תעבור קומפילציה אם ישנה הגדרת `#define PI` בקובץ `module1.h` ששונה מההגדרה בתוכנית הראשית",
      "התוכנית תעבור קומפילציה ללא תלות בתוכן הקובץ `module1.h` ותדפיס `Hello` 5 פעמים",
      "התוכנית תעבור קומפילציה ללא תלות בתוכן הקובץ `module1.h` ותדפיס `Hello` 4 פעמים",
      "התוכנית תעבור קומפילציה אך נקבל שגיאת זמן ריצה",
      "יותר מתשובה אחת נכונה",
      "אף תשובה אינה נכונה",
    ],
    correct: 0,
    hint: "חשבו על השלב שבו הוראות כמו `#define` ו־`#include` מטופלות. מה קורה אם הקדם־מעבד (preprocessor) נתקל בהגדרה כפולה של אותו סמל (macro) עם ערכים שונים?",
    explanation:
      "התשובה הנכונה היא שהתוכנית לא תעבור קומפילציה אם קיימת הגדרה סותרת בקובץ הכותר. הקדם־מעבד של שפת־C אינו מאפשר להגדיר מאקרו עם שם מסוים יותר מפעם אחת עם ערכים שונים. אם הקובץ `module1.h` מכיל הגדרה כמו `#define PI 3.14159`, והקוד הראשי מגדיר `#define PI 3.14`, הקדם־מעבד יזהה זאת כהגדרה מחדש (redeclaration) ויפיק שגיאה שתמנע את המשך הקומפילציה.\n\nכדי לשנות ערך של מאקרו שכבר הוגדר, יש לבטל תחילה את ההגדרה הקיימת באמצעות הוראת `#undef`, ורק לאחר מכן להגדיר את המאקרו מחדש עם הערך החדש.",
  },
  {
    code: `#define X 3
#ifdef X
    printf("Computer");
#else
    printf("Science");
#endif

int main()
{
    return 0;
}`,
    question: "מה תהיה התוצאה של הרצת קטע הקוד הבא?",
    answers: [
      "התוכנית אינה מתקמפלת",
      "`Computer`",
      "`Science`",
      "תתקבל שגיאה בזמן ריצה",
      "כל התשובות האחרות אינן נכונות",
    ],
    correct: 0,
    hint: "הקדם־מעבד (preprocessor) מטפל בהוראות כמו `#ifdef` לפני שהקומפיילר רואה את הקוד. שימו לב היכן ממוקמת הפקודה שנותרת לאחר פעולת הקדם־מעבד, וחשבו האם המיקום שלה חוקי על פי כללי התחביר של שפת־C.",
    explanation:
      'התוכנית תיכשל בשלב הקומפילציה ולא תפיק פלט. הסיבה לכך היא שהקדם־מעבד (preprocessor) מזהה שהסמל `X` מוגדר, ולכן הוא משאיר בקוד את השורה `printf("Computer");` ומסיר את החלק שתחת `#else`.\n\nעם זאת, פקודת ההדפסה הזו ממוקמת מחוץ לפונקציית ה־`main` או כל פונקציה אחרת. הדבר מהווה שגיאה תחבירית בשפת־C, שכן קוד המיועד לביצוע חייב להיכתב בתוך פונקציה. כתוצאה מכך, המהדר (compiler) יוציא שגיאה והתוכנית לא תיבנה או תרוץ.',
  },
];
