// quizzes/strings.js
const quizData = [
  {
    code: "void foo(int n, int m, char *s)\n{\n    char x[2] = { 0 };\n\n    *x = m + 'A';\n    strcat(s, x);\n\n    if ( (m == 0) || (m == n) )\n        return;\n\n    foo(n, m-1, s);\n    *x = n + '0';\n    strcat(s, x);\n    foo(n-1, m-1, s);\n}\n\nvoid main()\n{\n    char s[100] = { 0 };\n    foo( 4, 2, s);\n}",
    question: "מה יהיה תוכן המחרוזת s בסוף התכנית?",
    answers: [
      "CBA4A4BA3A",
      "CBA4A4AB3A",
      "CBA4A3BA23A",
      "CBA4A4BA23A",
      "CBA4B4BA3A",
      "אף תשובה מהתשובות האחרות אינה נכונה",
    ],
    correct: 0,
    hint: "עקבו אחר הקריאות הרקורסיביות לפונקציה `foo` ורשמו על דף את תוכן המחרוזת `s` לאחר כל קריאה ל־`strcat` (הפונקציה שמשרשרת מחרוזות). זכרו שהמחרוזת `s` משתנה באופן רציף לאורך כל ריצת התכנית.",
    explanation:
      "הפונקציה `foo` היא פונקציה רקורסיבית מורכבת הבונה את המחרוזת `s`. נבצע מעקב אחר הקריאות החל מ־`foo(4, 2)`:\n\n1. `foo(4,2)`: מוסיפה `C` למחרוזת וקוראת ל־`foo(4,1)`.\n2. `foo(4,1)`: מוסיפה `B` וקוראת ל־`foo(4,0)`.\n3. `foo(4,0)`: מוסיפה `A` וחוזרת (תנאי עצירה `m==0`). `s` כעת: `CBA`.\n\nכעת חוזרים מהרקורסיה. לאחר החזרה ל־`foo(4,1)`, הפונקציה מוסיפה `4` וקוראת ל־`foo(3,0)`. `foo(3,0)` מוסיפה `A` וחוזרת. `s` כעת: `CBA4A`. כעת חוזרים מ־`foo(4,1)` אל `foo(4,2)`. הפונקציה מוסיפה `4` וקוראת ל־`foo(3,1)`.\n\nהקריאה ל־`foo(3,1)` היא ענף רקורסיבי נוסף. היא מוסיפה `B`, קוראת ל־`foo(3,0)` (שמוסיפה `A`), חוזרת, מוסיפה `3`, וקוראת ל־`foo(2,0)` (שמוסיפה `A`). לאחר כל הפעולות הללו, המחרוזת הסופית היא `CBA4A4BA3A`.",
  },
  {
    code: 'char* s = "IHGFEDCBA";\nint j = 2;\n\nvoid f(char *s)\n{\n    static int i = 2;\n    {\n        static int j;\n        printf("%c %c ", s[i], s[j]);\n        i++;\n    }\n    j++;\n}\n\nvoid main()\n{\n    f(s);\n    s += 2;\n    f(s);\n}',
    question: "מה יהיה הפלט של התכנית הבאה?",
    answers: [
      "G I D G",
      "G I F I",
      "G I D F",
      "התוכנית תעוף בזמן ריצה",
      "התוכנית לא תתקמפל",
      "כל התשובות האחרות אינן נכונות",
    ],
    correct: 0,
    hint: "היקף ההכרה (scope) של משתנה סטטי מוגבל לבלוק שבו הוא הוגדר. שימו לב שיש שני משתנים בשם `j` בתכנית. נסו להבין על מי מבין שניהם פקודת ה־`++` משפיעה.",
    explanation:
      "בקריאה הראשונה ל־`f(s)`, `s` מצביע לתחילת המחרוזת. המשתנה הסטטי `i` מאותחל ל־2, והמשתנה הסטטי `j` (שבתוך הבלוק הפנימי) מאותחל ל־0 (ערך ברירת המחדל למשתנה סטטי). ההדפסה הראשונה תהיה `s[2]` (`'G'`) ו־`s[0]` (`'I'`). לאחר מכן `i` גדל ל־3, והמשתנה `j` הגלובלי (שמחוץ לבלוק הפנימי) גדל ל־3.\n\nלפני הקריאה השנייה, המצביע `s` מקודם בשני תאים וכעת מצביע לתו `'G'` המקורי. בקריאה השנייה ל־`f(s)`, המשתנים הסטטיים `i` ו־`j` שומרים על ערכם מהקריאה הקודמת (`i=3`, `j=0`). ההדפסה תהיה `s[3]` (שהוא התו באינדקס `2+3=5` מהמחרוזת המקורית, כלומר `'D'`) ו־`s[0]` (שהוא התו באינדקס `2+0=2` מהמחרוזת המקורית, כלומר `'G'`). הפלט המצטבר הוא `G I D G`.",
  },
  {
    code: "void f(char a, char b, char c)\n{\n    if (a == 'A' || b == 'A' || c == 'A')\n        return;\n\n    f(b - 1, a - 1, c);\n    printf(\"%c%c%c\", a, b, c);\n    f(c - 1, b - 1, a);\n}\n\nvoid main()\n{\n    f('D', 'C', 'D');\n}",
    question: "מה יהיה הפלט של התכנית הבאה?",
    answers: [
      "BCDCBBDCDCBD",
      "BCDCCBCCDCBD",
      "BCDCBBDCDDBC",
      "BCDCBCCCCBD",
      "DBCCBBDCDCBD",
      "כל התשובות האחרות אינן נכונות",
    ],
    correct: 0,
    hint: "זוהי רקורסיה מורכבת. בעת המעקב, שימו לב שבקריאות הרקורסיביות הסדר של המשתנים המועברים משתנה ואינו נשאר `a,b,c`.",
    explanation:
      "הפונקציה `f` היא פונקציה רקורסיבית, והפלט נוצר על ידי קריאות `printf` המבוצעות בין שתי קריאות רקורסיביות (בסדר המזכיר סריקת `in-order` של עץ). הדרך הטובה ביותר לפתור זאת היא לעקוב אחר עץ הקריאות.\n\nהקריאה הראשית `f('D','C','D')` מפעילה ענף רקורסיבי שמאלי (`f('B','C','D')`), מדפיסה `DCD`, ולאחר מכן מפעילה ענף ימני (`f('C','B','D')`). כל אחת מהקריאות הללו מתפצלת באופן דומה עד שתנאי העצירה (כאשר אחד הפרמטרים מגיע לערך `'A'`) מתקיים.\n\nכאשר עוקבים אחר סדר ההדפסה לפי סדר הביצוע, מתקבל השרשור הבא: תחילה `BCD`, אחריו `CBB`, לאחר מכן `DCD` מהקריאה הראשית, ולבסוף `CBD`. התוצאה הסופית המורכבת היא `BCDCBBDCDCBD`.",
  },
  {
    code: 'int main()\n{\n    char student[100] = "Avi Lavie";\n    char *teacher;\n\n    /* line 1*/ strcpy(teacher,student);\n    /* line 2*/ teacher = student;\n    /* line 3*/ strcpy(student,"Albert Einstein");\n    /* line 4*/ student = teacher;\n    return 0;\n}',
    question: "אילו מהשורות 1-4 תקינות (מתקמפלות ואינן מכילות באגים):",
    answers: ["2,3", "2,4", "2,3,4", "1,2,4", "1,2,3"],
    correct: 0,
    hint: "זכרו תמיד לאתחל מצביעים לפני השימוש בהם. בנוסף, חשבו על ההבדל המהותי בין מצביע רגיל לבין שם של מערך, ואיזה מהם ניתן להשמה מחדש.",
    explanation:
      "השורות התקינות היחידות הן 2 ו-3. נסביר מדוע כל שורה תקינה או לא:\n\n- שורה 1 `strcpy(teacher,student);`: שורה זו אינה תקינה. המצביע `teacher` הוגדר אך לא אותחל, ולכן הוא מצביע לכתובת אקראית ('זבל') בזיכרון. הפונקציה `strcpy` מנסה להעתיק את תוכן המחרוזת `student` לתוך אותה כתובת לא חוקית, פעולה שתוביל לשגיאת זמן ריצה (Segmentation Fault).\n\n- שורה 4 `student = teacher;`: שורה זו כלל לא תעבור קומפילציה. ב-C, שם של מערך (כמו `student`) הוא למעשה מצביע קבוע לכתובת הזיכרון שבה המערך מתחיל. לא ניתן לשנות את הכתובת הזו ולהפוך אותה למצביע למקום אחר. הקומפיילר יחזיר שגיאה על ניסיון שינוי של ערך שאינו ניתן לשינוי (`l-value`).\n\n- שורות 2 ו-3 תקינות: שורה 2 גורמת למצביע `teacher` להצביע על תחילת המערך `student`, וזו פעולה חוקית. שורה 3 מעתיקה מחרוזת חדשה לתוך המערך `student`, וזו גם פעולה חוקית כיוון שהוקצה למערך מספיק מקום.",
  },
  {
    code: "#include <stdio.h>\n\nvoid foo(int n, char a, char b, char c)\n{\n    if (n == 1)\n    {\n        printf(\"%c%c\", a, b);\n        return;\n    }\n    foo(n-1, a, c, b);\n    printf(\"%c%c\", a, b);\n    foo(n-1, c, b, a);\n}\n\nint main()\n{\n    foo(3, 'A', 'C', 'B');\n}",
    question: "מה שמונת התווים הראשונים שיודפסו על המסך?",
    answers: [
      "ACABCBAC",
      "ACABCBBC",
      "ACABCBBA",
      "ACCBCBAC",
      "ACABBCAC",
      "אף תשובה מהתשובות האחרות אינה נכונה",
    ],
    correct: 0,
    hint: "זוהי רקורסיה מורכבת. בעת המעקב, שימו לב שבקריאות הרקורסיביות הסדר של הפרמטרים המועברים משתנה ואינו נשאר `a,b,c`.",
    explanation:
      "הפונקציה `foo` מבצעת רקורסיה הדומה במבנה שלה לפתרון בעיית מגדלי האנוי. הפלט נוצר על ידי מעבר `in-order` על עץ הקריאות הרקורסיביות.\n\nהקריאה הראשית היא `foo(3, 'A', 'C', 'B')`. נתחקה אחר הקריאות עד שנקבל 8 תווים:\n1. הקריאה יורדת ל־`foo(2, 'A', 'B', 'C')`.\n2. הקריאה יורדת שוב ל־`foo(1, 'A', 'C', 'B')`. זוהי קריאת בסיס, והיא מדפיסה `AC`.\n3. חוזרים ל־`foo(2,...)`, ושם מודפס `AB`. הפלט עד כה: `ACAB`.\n4. מתוך `foo(2,...)`, מתבצעת קריאה ל־`foo(1, 'C', 'B', 'A')`. זו קריאת בסיס, והיא מדפיסה `CB`. הפלט עד כה: `ACABCB`.\n5. חוזרים מ־`foo(2,...)` לקריאה הראשית `foo(3,...)`, שם מודפס `AC`. הפלט עד כה: `ACABCBAC`.\n\nבשלב זה כבר יש לנו 8 תווים, והם תואמים לתשובה הנכונה.",
  },
  {
    code: 'void bar(const char* src, char* dest) {\n    int i = 0;\n    while (src[i] != \'\\0\') { \n        dest[i] = src[i]; \n        i++; \n    }\n}\n\nint main(void)\n{\n    char str1[] = "software"; \n    char str2[] = "project"; \n    bar(str2, str1); \n    printf("%s\\n", str1); \n    return 0;\n}',
    question: "מה יהיה הפלט של התכנית הבאה?",
    answers: [
      "sroject",
      "project",
      "projecte",
      "roject",
      "יתר התשובות אינן נכונות",
    ],
    correct: 2,
    hint: "הפונקציה `bar` מעתיקה תווים מהמקור ליעד, אך שימו לב לאן היא מעתיקה ומהו תנאי העצירה שלה. האם היא מעתיקה גם את תו ה-`NULL` הסוגר את המחרוזת? ומה קורה לתווים המקוריים במחרוזת היעד שלא נדרסים?",
    explanation:
      "הפונקציה `bar` מממשת באופן חלקי את פעולת `strcpy`. היא מעתיקה את התווים מהמחרוזת `str2` (`\"project\"`) אל תוך המחרוזת `str1` (`\"software\"`).\n\nהלולאה מעתיקה את 7 התווים של `\"project\"` ומציבה אותם בשבעת המקומות הראשונים של `str1`. לאחר ההעתקה, זיכרון המערך `str1`, שהיה בגודל 9 (`software\\0`), ייראה כך: `{'p','r','o','j','e','c','t','e','\\0'}`. התו `'e'` שהיה במקום השמיני במחרוזת המקורית (`\"software\"`) נשאר במקומו, כיוון שההעתקה נעצרה לפני שהגיעה אליו. חשוב מכך, הלולאה נעצרת כאשר היא מגיעה לתו `NULL` במחרוזת המקור, אך היא אינה מעתיקה אותו ליעד.\n\nכתוצאה מכך, תו ה־`NULL` המקורי של `str1` נשאר בסוף המערך. כאשר הפונקציה `printf` נקראת, היא מדפיסה את כל התווים מתחילת `str1` ועד שהיא פוגשת את תו ה־`NULL` הראשון, ולכן הפלט יהיה `projecte`.",
  },
  {
    code: '#include<stdio.h>\n\nchar *funA()\n{\n    char *str = "A";\n    return str;\n}\n\nchar *funB()\n{\n    char str[] = "B";\n    return str;\n}\n\nint main()\n{\n    printf("%s", funA());\n    printf("%s", funB());\n    return 0;\n}',
    question: "מה יהיה הפלט של התכנית הבאה?",
    answers: [
      "AB",
      "יודפסו שני תווי זבל",
      "A ואחריו תו זבל",
      "כל התשובות האחרות אינן נכונות",
      "יודפס תו זבל ואחריו B",
    ],
    correct: 3,
    hint: 'יש הבדל מהותי באופן שבו הזיכרון מוקצה בשתי הפונקציות. חישבו היכן בזיכרון מאוחסנת המחרוזת "A" ב־`funA` (כאשר משתמשים ב־`char*`), לעומת היכן מאוחסנת המחרוזת "B" ב־`funB` (כאשר משתמשים ב־`char[]`).',
    explanation:
      "ההבדל המהותי בין שתי הפונקציות הוא במיקום הזיכרון של המחרוזות. ב־`funA`, הביטוי `char *str = \"A\";` גורם למצביע `str` להצביע על המחרוזת הליטרלית `\"A\"`. מחרוזות אלו נשמרות באזור זיכרון סטטי וקבוע של התכנית, שאינו חלק מהמחסנית (stack) שעליה יושבות הפונקציות. זיכרון זה זמין תמיד, ולכן החזרת המצביע תקינה וההדפסה הראשונה תציג `A`.\n\nב־`funB`, לעומת זאת, הביטוי `char str[] = \"B\";` יוצר מערך תווים מקומי על המחסנית. זיכרון זה משתחרר והופך לא חוקי ברגע שהפונקציה מסיימת. הניסיון להדפיס מהמצביע המוחזר גורם ל'התנהגות בלתי מוגדרת' (Undefined Behavior).\n\nהתנהגות בלתי מוגדרת משמעה שלא ניתן לקבוע מה יקרה. התכנית עשויה להדפיס 'זבל', לקרוס, או אפילו להדפיס `B` בטעות. מכיוון שאף תשובה אינה מתארת באופן ודאי את התוצאה (למשל, התשובה 'A ואחריו תו זבל' היא רק אפשרות אחת מני רבות), אף אחת מהן אינה נכונה בוודאות. לכן, התשובה הנכונה ביותר היא שכל התשובות האחרות אינן נכונות.",
  },
  {
    code: `char s1[10][20];
char *s2[10];
char **s3;`,
    question:
      "בהינתן הגדרות המשתנים בקוד, איזו מהטענות הבאות היא הנכונה ביותר?",
    answers: [
      "`s3` מאפשרת מספר משתנה של מחרוזות כאשר לכל אחת יכול להיות אורך שונה",
      "`s2` מגדירה מערך של 10 מחרוזות כאשר לכל אחת יכול להיות אורך שונה",
      "`s1` מגדירה מערך של 10 מחרוזות אשר כל אחת יכולה להכיל עד 19 תווים",
      "`s2` מגדירה מערך של 10 מחרוזות אשר כולן חייבות להיות באותו אורך",
      "יותר מטענה אחת לעיל נכונה",
      "אף טענה לעיל אינה נכונה",
    ],
    correct: 4,
    hint: "חשבו על ההבדל בין הקצאת זיכרון סטטית על המחסנית (stack), שימוש במערך של מצביעים, ושימוש במצביע למצביע. איזו שיטה הכי פחות גמישה ואיזו הכי הרבה, ומה המשמעות לגבי אורך המחרוזות?",
    explanation:
      "התשובה הנכונה היא שיותר מטענה אחת נכונה.\n\nההגדרה `char s1[10][20]` יוצרת מערך דו־ממדי בגודל קבוע. יש בו 10 איברים, כאשר כל איבר הוא מערך של 20 תווים. לכן, כל אחת מ־10 המחרוזות יכולה להכיל לכל היותר 19 תווים, והתו ה־20 נשמר עבור תו הסיום `\\0`. ואכן, אחת מהתשובות אומרת בדיוק את זה.\n\nההגדרה `char *s2[10]` יוצרת מערך בגודל קבוע של 10 איברים, שכל אחד מהם הוא מצביע לתו. כל מצביע כזה יכול להצביע למחרוזת באורך שונה, שמוקצית בנפרד (באופן דינמי או על ידי הפניה למחרוזת קבועה). ואכן, אחת מהתשובות אומרת שזוהי דרך להגדיר 10 מחרוזות באורכים פוטנציאליים שונים. \n\nכיוון שמצאנו שתי תשובות נכונות, ברור שהתשובה הנכונה ביותר היא שיותר מטענה אחת נכונה. בכל מקרה, נמשיך לצורך ההסבר לשורה האחרונה.\n\nההגדרה `char **s3` יוצרת מצביע למצביע לתו, וזהו המבנה הגמיש ביותר. ניתן להקצות עבור `s3` מערך דינמי של מצביעים בכל גודל, ולאחר מכן להקצות עבור כל מצביע כזה מחרוזת בכל אורך. לכן, המבנה מאפשר מספר משתנה של מחרוזות וגם אורך שונה לכל אחת. ושוב, גם כאן יש תשובה שאומרת את זה.",
  },
  {
    code: `char *s = "123456789";
int y = 1;

void f(char *s)
{
    static int x = 5;
    int y = 0;

    printf("%c ", s[x + y]);
    x -= 2;
    y++;
}

int main()
{
    f(s);
    f(s + y);
    return 0;
}`,
    question: "מה יודפס על ידי הקריאה השנייה לפונקציה `f`?",
    answers: ["5", "7", "4", "6", "כל התשובות האחרות אינן נכונות"],
    correct: 0,
    hint: "שימו לב לשני פרטים חשובים: מה קורה לערכו של משתנה סטטי בין קריאות שונות לפונקציה, ומהי המחרוזת שהפונקציה `f` מקבלת בפועל בקריאה השנייה אליה?",
    explanation:
      "התנהגות התוכנית נקבעת על ידי שני רכיבים מרכזיים: המשתנה הסטטי `x` בתוך הפונקציה `f`, והמצביע `s` שמועבר אליה. בקריאה הראשונה, `f(s)`, המשתנה הסטטי `x` מאותחל ל־5. הפונקציה מדפיסה את התו באינדקס 5 (כלומר `x+y` שהוא `5+0`) מהמחרוזת המקורית, שזהו התו '6'. לאחר ההדפסה, ערכו של `x` יורד ב־2 והופך ל־3, והוא ישמור על ערך זה לקראת הקריאה הבאה.\n\nבקריאה השנייה, `f(s + y)`, שני דברים משתנים. ראשית, המצביע המועבר לפונקציה הוא `s + 1` (כיוון שהמשתנה הגלובלי `y` שווה 1), ולכן הפונקציה רואה את המחרוזת כמתחילה מהתו השני, `\"23456789\"`. שנית, המשתנה הסטטי `x` ממשיך מהערך הקודם שלו, 3, ולא מאותחל מחדש. לכן, הפונקציה מדפיסה את התו באינדקס 3 מהמחרוזת החדשה שהיא קיבלה, שזהו התו '5'.",
  },
  {
    code: `void print_args_reverse(void *p, void *s)
{
    while (p!=s) {
        printf("%s\\n", [[1]] p);
        p = [[2]] p-1;
    }
}

void main(int argc, char *argv[])
{
    print_args_reverse( [[3]] , argv);
}`,
    question:
      "מה יש למלא במקומות הממוספרים 1 עד 3 כדי שהקוד ידפיס את הארגומנטים שהועברו אליו בסדר הפוך (מהאחרון לראשון, ללא שם התוכנית)?",
    answers: [
      "[[1: *(char**)]][[2: (char**)]][[3: argv+argc-1]]",
      "[[1: (char*)]][[2: (char*)]][[3: *(argv+argc-1)]]",
      "[[1: (char*)]][[2: (char*)]][[3: argv+argc-1]]",
      "[[1: *(char**)]][[2: (char**)]][[3: *(argv+argc-1)]]",
      "כל התשובות האחרות אינן נכונות",
    ],
    correct: 0,
    hint: "זכרו שמערך הארגומנטים `argv` הוא מסוג `char**`. כדי לעבור עליו בסדר הפוך, עליכם להגדיר מצביע שמתחיל מהאיבר האחרון ומצביע שמסמן את נקודת העצירה. חשבו אילו פעולות המרה (casting) וגישה לזיכרון (dereferencing) נדרשות כדי להדפיס את המחרוזת הנכונה בכל שלב.",
    explanation:
      "המטרה היא לעבור על מערך הארגומנטים `argv` מהסוף להתחלה. לשם כך, הפונקציה `print_args_reverse` מקבלת שני מצביעים: `p` שמתחיל מהסוף, ו־`s` שמהווה את תנאי העצירה.\n\nבתיבה 3 יש להעביר את המצביע לארגומנט האחרון. מערך הארגומנטים `argv` מכיל `argc` איברים, והאיבר האחרון נמצא באינדקס `argc-1`. הכתובת של איבר זה היא `argv + argc - 1`. נקודת העצירה, `s`, כבר מועברת בתור `argv`, כך שהלולאה תעצור לפני שתעבד את `argv[0]` (שם התוכנית).\n\nבתיבה 1, המטרה היא להדפיס את המחרוזת. המשתנה `p` הוא `void*`, אך בפועל הוא מצביע למצביע לתו (`char**`). כדי לגשת למחרוזת (`char*`) ולהדפיס אותה עם `printf`, עלינו לבצע המרה של `p` ל־`char**` ולאחר מכן לבצע דה־רפרנסינג (פעולת `*`) כדי לקבל את המצביע למחרוזת. לכן, ההשלמה הנכונה היא `*(char**)`.\n\nבתיבה 2, עלינו לקדם את המצביע `p` אחורה. לא ניתן לבצע אריתמטיקה על מצביעי `void*`. יש לבצע המרה של `p` לסוגו האמיתי, `char**`, כדי שהקומפיילר יידע בכמה בתים יש לקדם את המצביע אחורה (גודל של `char*`). לכן, ההשלמה הנכונה היא ההמרה `(char**)`.",
  },
  {
    code: `#include <stdio.h>

void print(void *a)
{
    char **p = (char **)a;

    puts(*p + 1);
    putchar(**p + 1);
}

int main(int argc, char *argv[])
{
    for (int i = 1; i < argc; i++)
        print(argv + i);

    return 0;
}`,
    question:
      "מה יהיה פלט התוכנית אם נפעיל אותה עם הארגומנטים הבאים `aaa eee iii`? (הסימן `↵` מייצג ירידת שורה)",
    answers: [
      "אף תשובה מהתשובות האחרות אינה נכונה",
      "aaa↵beee↵fiii↵j",
      "aaa↵beee↵fiii↵jj",
      "בקוד יש טעות קומפילציה",
      "aa↵be↵fi↵jj",
      "aa↵bee↵fii↵j",
    ],
    correct: 5,
    hint: "שימו לב היטב לפעולות המבוצעות בתוך הפונקציה `print`. הפונקציה `puts` מדפיסה מחרוזת החל ממיקום מסוים, והפונקציה `putchar` מדפיסה תו בודד. עקבו אחר ערך המצביע `p` בכל איטרציה של הלולאה.",
    explanation:
      'התוכנית מקבלת ארגומנטים משורת הפקודה וקוראת לפונקציה `print` עבור כל אחד מהם, החל מהארגומנט הראשון. ננתח את פעולת הפונקציה `print` עבור כל קריאה.\n\nבקריאה הראשונה, עם הארגומנט `"aaa"`, המצביע `p` מצביע למחרוזת זו. הפקודה `puts(*p + 1)` מדפיסה את המחרוזת החל מהתו השני, כלומר `"aa"`, בתוספת ירידת שורה. הפקודה `putchar(**p + 1)` לוקחת את התו הראשון (`\'a\'`), מוסיפה לו 1 (מקבלת את `\'b\'`) ומדפיסה אותו. הפלט מהקריאה הראשונה הוא `aa↵b`.\n\nבקריאה השנייה, עם הארגומנט `"eee"`, התהליך זהה. `puts(*p + 1)` מדפיס `"ee"` ויורד שורה. `putchar(**p + 1)` מדפיס את התו `\'f\'`. הפלט מהקריאה השנייה הוא `ee↵f`.\n\nבקריאה השלישית, עם הארגומנט `"iii"`, הפונקציה `puts` מדפיסה `"ii"` ויורדת שורה, והפונקציה `putchar` מדפיסה את התו `\'j\'`. הפלט מהקריאה השלישית הוא `ii↵j`. שרשור כל הפלטים יחד לפי הסדר נותן את התוצאה הסופית.',
  },
];
