// עבר בדיקה
const quizData = [
  {
    code: `void print(void *a) {
    char **p = (char **)a;

    puts(*p + 1);
    putchar(**p + 1);
}

int main(int argc, char *argv[]) {
    for (int i = 1; i < argc; i++)
        print(argv + i);

    return 0;
}`,
    question:
      "מה יהיה פלט התוכנית אם נפעיל אותה עם הארגומנטים הבאים `aaa eee iii`? (הסימן `↵` מייצג ירידת שורה)",
    answers: [
      "אף תשובה מהתשובות האחרות אינה נכונה",
      "`aaa↵beee↵fiii↵j`",
      "`aaa↵beee↵fiii↵jj`",
      "בקוד יש טעות קומפילציה",
      "`aa↵be↵fi↵jj`",
      "`aa↵bee↵fii↵j`",
    ],
    correct: 5,
    hint: "שימו לב היטב לפעולות המבוצעות בתוך הפונקציה `print`. איך עובדת פונקציית `puts`? ואיך `putchar`? אם אתם לא זוכרים, תפתחו את דף הנוסחאות המעודכן.",
    explanation: `בקריאה הראשונה, עם הארגומנט "aaa", המשתנה \`p\` הוא מצביע ל־\`char*\`, והוא מאותחל ל־\`argv + i\`, כלומר לכתובת של מחרוזת אחת בתוך המערך. כך ש־\`*p\` מחלץ את המצביע למחרוזת עצמה — במקרה זה, \`*p == "aaa"\`.\n\nהביטוי \`*p + 1\` הוא נקודה מעניינת שראויה להבהרה: מאחר ש־\`*p\` הוא מצביע למחרוזת (\`char*\`), אז \`*p + 1\` פירושו להזיז את המצביע למחרוזת באחד קדימה, כלומר לדלג על התו הראשון. כך מתקבלת כתובת שמצביעה לתו השני במחרוזת, והמחרוזת החדשה שתתחיל ממנו תהיה "aa". לכן, \`puts(*p + 1)\` תדפיס את "aa" עם ירידת שורה.\n\nזה עלול להיות מבלבל, כי לרגע נדמה ש־\`*p + 1\` מדלג על תא אחד במערך של מחרוזות — אך חשוב לזכור ש־\`*p\` כבר מחלץ את המחרוזת עצמה, ולכן ההזזה ב־\`+1\` מתבצעת בתוך המחרוזת עצמה, ולא במערך \`argv\`.\n\nהביטוי \`**p + 1\` שווה לתו הראשון של המחרוזת, בתוספת 1 מבחינה מספרית. כלומר אם התו הראשון הוא 'a', אז \`**p == 'a'\`, והוספת 1 תיתן את התו 'b'. \`putchar(**p + 1)\` מדפיס את התו החדש הזה, בלי ירידת שורה.\n\nבקריאה הראשונה, "aaa", מתקבל הפלט aa↵b. בשנייה, "eee", מתקבל ee↵f. בשלישית, "iii", מתקבל ii↵j. שרשור כל הפלטים יחד לפי סדר הקריאות נותן את התוצאה הסופית.`,
  },
  {
    code: `void foo(int n, int m, char *s) {
    char x[2] = { 0 };

    *x = m + 'A';
    strcat(s, x);

    if ( (m == 0) || (m == n) )
        return;

    foo(n, m-1, s);
    *x = n + '0';
    strcat(s, x);
    foo(n-1, m-1, s);
}

void main() {
    char s[100] = { 0 };
    foo( 4, 2, s);
}`,
    question: "מה יהיה תוכן המחרוזת `s` בסוף התכנית?",
    answers: [
      "`CBA4A4BA3A`",
      "`CBA4A4AB3A`",
      "`CBA4A3BA23A`",
      "`CBA4A4BA23A`",
      "`CBA4B4BA3A`",
      "אף תשובה מהתשובות האחרות אינה נכונה",
    ],
    correct: 0,
    hint: "עקבו אחר הקריאות הרקורסיביות לפונקציה `foo` ורשמו על דף את תוכן המחרוזת `s` לאחר כל קריאה ל־`strcat`. זכרו שהמחרוזת `s` משתנה באופן רציף לאורך כל ריצת התכנית.",
    explanation:
      "הפונקציה `foo` היא פונקציה רקורסיבית מורכבת הבונה את המחרוזת `s`. נבצע מעקב אחר הקריאות החל מ־`foo(4, 2)`.\n\nהקריאה `foo(4,2)` מוסיפה `C` וקוראת ל־`foo(4,1)`. קריאה זו מוסיפה `B` וקוראת ל־`foo(4,0)`, שמוסיפה `A` וחוזרת. בשלב זה, `s` הוא `CBA`.\n\nכעת חוזרים מהרקורסיה. ב־`foo(4,1)`, הפונקציה מוסיפה `4` וקוראת ל־`foo(3,0)`, שמוסיפה `A`. `s` כעת הוא `CBA4A`. חוזרים מ־`foo(4,1)` אל `foo(4,2)`, שם מתווסף `4` ומתבצעת קריאה ל־`foo(3,1)`.\n\nהקריאה ל־`foo(3,1)` היא ענף רקורסיבי נוסף. היא מוסיפה `B`, קוראת ל־`foo(3,0)` (שמוסיפה `A`), חוזרת, מוסיפה `3`, וקוראת ל־`foo(2,0)` (שמוסיפה `A`). לאחר כל הפעולות הללו, המחרוזת הסופית היא `CBA4A4BA3A`.",
  },
  {
    code: `char* s = "IHGFEDCBA";
int j = 2;

void f(char *s) {

    static int i = 2;

    {
        static int j;
        printf("%c %c ", s[i], s[j]);
        i++;
    }

    j++;
}

void main() {
    f(s);
    s += 2;
    f(s);
}`,
    question: "מה יהיה הפלט של התכנית הבאה?",
    answers: [
      "`G I D G`",
      "`G I F I`",
      "`G I D F`",
      "התוכנית תעוף בזמן ריצה",
      "התוכנית לא תתקמפל",
      "כל התשובות האחרות אינן נכונות",
    ],
    correct: 0,
    hint: "היקף ההכרה (scope) של משתנה סטטי מוגבל לבלוק שבו הוא הוגדר. שימו לב שיש שני משתנים בשם `j` בתכנית. נסו להבין על מי מבין שניהם פקודת ה־`++` משפיעה.",
    explanation:
      "בקריאה הראשונה ל־`f(s)`, המצביע `s` מצביע לתחילת המחרוזת. המשתנה הסטטי `i` מאותחל ל־2, והמשתנה הסטטי `j` (שבתוך הבלוק הפנימי) מאותחל ל־0 (ערך ברירת המחדל למשתנה סטטי). ההדפסה הראשונה תהיה `s[2]` (`'G'`) ו־`s[0]` (`'I'`). לאחר מכן `i` גדל ל־3, והמשתנה `j` הגלובלי (שמחוץ לבלוק הפנימי) גדל ל־3.\n\nלפני הקריאה השנייה, המצביע `s` מקודם בשני תאים וכעת מצביע לתו `'G'` המקורי. בקריאה השנייה ל־`f(s)`, המשתנים הסטטיים `i` ו־`j` שומרים על ערכם מהקריאה הקודמת (`i=3`, `j=0`). ההדפסה תהיה `s[3]` (שהוא התו באינדקס `2+3=5` מהמחרוזת המקורית, כלומר `'D'`) ו־`s[0]` (שהוא התו באינדקס `2+0=2` מהמחרוזת המקורית, כלומר `'G'`). הפלט המצטבר הוא `G I D G`.",
  },
  {
    code: `void f(char a, char b, char c) {
    if (a == 'A' || b == 'A' || c == 'A')
        return;

    f(b - 1, a - 1, c);
    printf("%c%c%c", a, b, c);
    f(c - 1, b - 1, a);
}

void main() {
    f('D', 'C', 'D');
}`,
    question: "מה יהיה הפלט של התכנית הבאה?",
    answers: [
      "`BCDCBBDCDCBD`",
      "`BCDCCBCCDCBD`",
      "`BCDCBBDCDDBC`",
      "`BCDCBCCCCBD`",
      "`DBCCBBDCDCBD`",
      "כל התשובות האחרות אינן נכונות",
    ],
    correct: 0,
    hint: "זוהי רקורסיה מורכבת. בעת המעקב, שימו לב שבקריאות הרקורסיביות הסדר של המשתנים המועברים משתנה ואינו נשאר `a,b,c`.",
    explanation:
      "הפונקציה `f` היא פונקציה רקורסיבית, והפלט נוצר על ידי קריאות `printf` המבוצעות בין שתי קריאות רקורסיביות (בסדר המזכיר סריקת `in-order` של עץ). הדרך הטובה ביותר לפתור זאת היא לעקוב אחר עץ הקריאות.\n\nהקריאה הראשית `f('D','C','D')` מפעילה ענף רקורסיבי שמאלי (`f('B','C','D')`), מדפיסה `DCD`, ולאחר מכן מפעילה ענף ימני (`f('C','B','D')`). כל אחת מהקריאות הללו מתפצלת באופן דומה עד שתנאי העצירה (כאשר אחד הפרמטרים מגיע לערך `'A'`) מתקיים.\n\nכאשר עוקבים אחר סדר ההדפסה לפי סדר הביצוע, מתקבל השרשור הבא: תחילה `BCD`, אחריו `CBB`, לאחר מכן `DCD` מהקריאה הראשית, ולבסוף `CBD`. התוצאה הסופית המורכבת היא `BCDCBBDCDCBD`.",
  },
  {
    code: `int main() {

    char student[100] = "Avi Lavie";
    char *teacher;

    /* line 1*/ strcpy(teacher,student);
    /* line 2*/ teacher = student;
    /* line 3*/ strcpy(student,"Albert Einstein");
    /* line 4*/ student = teacher;
    return 0;
}`,
    question: "אילו מהשורות 1-4 תקינות (מתקמפלות ואינן מכילות באגים):",
    answers: ["2 ו־3", "2 ו־4", "2, 3 ו־4", "1, 2 ו־4", "1 ,2 ו־3"],
    correct: 0,
    hint: "זכרו תמיד לאתחל מצביעים לפני השימוש בהם. בנוסף, חשבו על ההבדל המהותי בין מצביע רגיל לבין שם של מערך, ואיזה מהם ניתן להשמה מחדש.",
    explanation:
      "השורות התקינות היחידות הן 2 ו־3. נסביר מדוע כל שורה תקינה או לא:\n\n- שורה 1 `strcpy(teacher,student);`: שורה זו אינה תקינה. המצביע `teacher` הוגדר אך לא אותחל, ולכן הוא מצביע לכתובת אקראית ('זבל') בזיכרון. הפונקציה `strcpy` מנסה להעתיק את תוכן המחרוזת `student` לתוך אותה כתובת לא חוקית, פעולה שתוביל לשגיאת זמן ריצה (Segmentation Fault).\n\n- שורה 4 `student = teacher;`: שורה זו כלל לא תעבור קומפילציה. ב־C, שם של מערך (כמו `student`) הוא למעשה מצביע קבוע לכתובת הזיכרון שבה המערך מתחיל. לא ניתן לשנות את הכתובת הזו ולהפוך אותה למצביע למקום אחר. הקומפיילר יחזיר שגיאה על ניסיון שינוי של ערך שאינו ניתן לשינוי (`l-value`).\n\n- שורות 2 ו-3 תקינות: שורה 2 גורמת למצביע `teacher` להצביע על תחילת המערך `student`, וזו פעולה חוקית. שורה 3 מעתיקה מחרוזת חדשה לתוך המערך `student`, וזו גם פעולה חוקית כיוון שהוקצה למערך מספיק מקום.",
  },
  {
    code: `void foo(int n, char a, char b, char c) {

    if (n == 1) {
        printf("%c%c", a, b);
        return;
    }

    foo(n-1, a, c, b);
    printf("%c%c", a, b);
    foo(n-1, c, b, a);
}

int main() {
    foo(3, 'A', 'C', 'B');
}`,
    question: "מה שמונת התווים הראשונים שיודפסו על המסך?",
    answers: [
      "`ACABCBAC`",
      "`ACABCBBC`",
      "`ACABCBBA`",
      "`ACCBCBAC`",
      "`ACABBCAC`",
      "אף תשובה מהתשובות האחרות אינה נכונה",
    ],
    correct: 0,
    hint: "זוהי רקורסיה מורכבת. בעת המעקב, שימו לב שבקריאות הרקורסיביות הסדר של הפרמטרים המועברים משתנה ואינו נשאר `a,b,c`.",
    explanation:
      "הפונקציה `foo` מבצעת רקורסיה הדומה במבנה שלה לסריקת `in-order` על עץ.\n\nהקריאה הראשית היא `foo(3, 'A', 'C', 'B')`. נתחקה אחר הקריאות עד שנקבל 8 תווים:\n1. הקריאה יורדת ל־`foo(2, 'A', 'B', 'C')`.\n2. הקריאה יורדת שוב ל־`foo(1, 'A', 'C', 'B')`. הגענו לתנאי עצירה, והפונקציה מדפיסה `AC`.\n3. חוזרים ל־`foo(2,...)`, ושם מודפס `AB`. הפלט עד כה: `ACAB`.\n4. מתוך `foo(2,...)`, מתבצעת קריאה ל־`foo(1, 'C', 'B', 'A')`. שוב הגענו לתנאי עצירה, והפונקציה מדפיסה `CB`. הפלט עד כה: `ACABCB`.\n5. חוזרים מ־`foo(2,...)` לקריאה הראשית `foo(3,...)`, שם מודפס `AC`. הפלט עד כה: `ACABCBAC`.\n\nהידד! יש לנו 8 תווים, והם תואמים לתשובה הנכונה.",
  },
  {
    code: `void bar(const char* src, char* dest) {
    int i = 0;
    while (src[i] != '\\0') { 
        dest[i] = src[i]; 
        i++; 
    }
}

int main(void) {
    char str1[] = "software"; 
    char str2[] = "project"; 
    bar(str2, str1); 
    printf("%s\\n", str1); 
    return 0;
}`,
    question: "מה יהיה הפלט של התכנית הבאה?",
    answers: [
      "`projecte`",
      "`project`",
      "`sroject`",
      "`roject`",
      "יתר התשובות אינן נכונות",
    ],
    correct: 0,
    hint: "הפונקציה `bar` מעתיקה תווים מהמקור ליעד, אך שימו לב לאן היא מעתיקה ומהו תנאי העצירה שלה. האם היא מעתיקה גם את תו ה-`NULL` הסוגר את המחרוזת? ומה קורה לתווים המקוריים במחרוזת היעד שלא נדרסים?",
    explanation:
      "הפונקציה `bar` מממשת באופן חלקי את פעולת `strcpy`. היא מעתיקה את התווים מהמחרוזת `str2` (`\"project\"`) אל תוך המחרוזת `str1` (`\"software\"`).\n\nהלולאה מעתיקה את 7 התווים של `\"project\"` ומציבה אותם בשבעת המקומות הראשונים של `str1`. לאחר ההעתקה, זיכרון המערך `str1`, שהיה בגודל 9 (`software\\0`), ייראה כך: `{'p','r','o','j','e','c','t','e','\\0'}`. התו `'e'` שהיה במקום השמיני במחרוזת המקורית (`\"software\"`) נשאר במקומו, כיוון שההעתקה נעצרה לפני שהגיעה אליו. חשוב מכך, הלולאה נעצרת כאשר היא מגיעה לתו `NULL` במחרוזת המקור, אך היא אינה מעתיקה אותו ליעד.\n\nכתוצאה מכך, תו ה־`NULL` המקורי של `str1` נשאר בסוף המערך. כאשר הפונקציה `printf` נקראת, היא מדפיסה את כל התווים מתחילת `str1` ועד שהיא פוגשת את תו ה־`NULL` הראשון, ולכן הפלט יהיה `projecte`.",
  },
  {
    code: `char *funA() {
    char *str = "A";
    return str;
}

char *funB() {
    char str[] = "B";
    return str;
}

int main() {
    printf("%s", funA());
    printf("%s", funB());
    return 0;
}`,
    question: "מה יהיה הפלט של התכנית הבאה?",
    answers: [
      "`AB`",
      "יודפסו שני תווי זבל",
      "`A` ואחריו תו זבל",
      "כל התשובות האחרות אינן נכונות",
      "יודפס תו זבל ואחריו `B`",
    ],
    correct: 3,
    hint: 'יש הבדל מהותי באופן שבו הזיכרון מוקצה בשתי הפונקציות. חישבו היכן בזיכרון מאוחסנת המחרוזת "A" ב־`funA` (כאשר משתמשים ב־`char*`), לעומת היכן מאוחסנת המחרוזת "B" ב־`funB` (כאשר משתמשים ב־`char[]`).',
    explanation:
      "ההבדל המהותי בין שתי הפונקציות הוא במיקום הזיכרון של המחרוזות. ב־`funA`, הביטוי `char *str = \"A\";` גורם למצביע `str` להצביע על המחרוזת הליטרלית `\"A\"`. מחרוזות אלו נשמרות באזור זיכרון סטטי וקבוע של התכנית, שאינו חלק מהמחסנית (stack) שעליה יושבות הפונקציות. זיכרון זה זמין תמיד, ולכן החזרת המצביע תקינה וההדפסה הראשונה תציג `A`.\n\nב־`funB`, לעומת זאת, הביטוי `char str[] = \"B\";` יוצר מערך תווים מקומי על המחסנית. זיכרון זה משתחרר והופך לא חוקי ברגע שהפונקציה מסיימת. הניסיון להדפיס מהמצביע המוחזר גורם ל'התנהגות בלתי מוגדרת' (Undefined Behavior).\n\nהתנהגות בלתי מוגדרת משמעה שלא ניתן לקבוע מה יקרה. התכנית עשויה להדפיס 'זבל', לקרוס, או אפילו להדפיס `B` בטעות. מכיוון שאף תשובה אינה מתארת באופן ודאי את התוצאה (למשל, התשובה 'A ואחריו תו זבל' היא רק אפשרות אחת מני רבות), אף אחת מהן אינה נכונה בוודאות. לכן, התשובה הנכונה ביותר היא שכל התשובות האחרות אינן נכונות.",
  },
  {
    code: `char s1[10]][20];
char *s2[10];
char **s3;`,
    question:
      "בהינתן הגדרות המשתנים בקוד, איזו מהטענות הבאות היא הנכונה ביותר?",
    answers: [
      "`s3` מאפשרת מספר משתנה של מחרוזות כאשר לכל אחת יכול להיות אורך שונה",
      "`s2` מגדירה מערך של 10 מחרוזות כאשר לכל אחת יכול להיות אורך שונה",
      "`s1` מגדירה מערך של 10 מחרוזות אשר כל אחת יכולה להכיל עד 19 תווים",
      "`s2` מגדירה מערך של 10 מחרוזות אשר כולן חייבות להיות באותו אורך",
      "יותר מטענה אחת נכונה",
      "אף טענה אינה נכונה",
    ],
    correct: 4,
    hint: "חשבו על ההבדל בין הקצאת זיכרון סטטית על המחסנית (stack), שימוש במערך של מצביעים, ושימוש במצביע למצביע. איזו שיטה הכי פחות גמישה ואיזו הכי הרבה, ומה המשמעות לגבי אורך המחרוזות?",
    explanation:
      "ההגדרה `char s1[10][20]` יוצרת מערך דו־ממדי בגודל קבוע. יש בו 10 איברים, כאשר כל איבר הוא מערך של 20 תווים. לכן, כל אחת מ־10 המחרוזות יכולה להכיל לכל היותר 19 תווים, והתו ה־20 נשמר עבור תו הסיום `\\0`. טענה זו מופיעה בתשובות.\n\nההגדרה `char *s2[10]` יוצרת מערך בגודל קבוע של 10 איברים, שכל אחד מהם הוא מצביע לתו. כל מצביע כזה יכול להצביע למחרוזת באורך שונה, שמוקצית בנפרד. טענה זו מופיעה גם היא.\n\nההגדרה `char **s3` יוצרת מצביע למצביע לתו. זה מבנה גמיש ביותר, המאפשר מספר משתנה של מחרוזות באורכים משתנים. גם טענה זו מופיעה.\n\nבקיצור, יש יותר מטענה אחת נכונה, ולכן זו התשובה המדויקת ביותר.",
  },
  {
    code: `char *s = "123456789";
int y = 1;

void f(char *s) {
    static int x = 5;
    int y = 0;

    printf("%c ", s[x + y]);
    x -= 2;
    y++;
}

int main() {
    f(s);
    f(s + y);
    return 0;
}`,
    question: "מה יודפס על ידי הקריאה השנייה לפונקציה `f`?",
    answers: ["`5`", "`7`", "`4`", "`6`", "כל התשובות האחרות אינן נכונות"],
    correct: 0,
    hint: "שימו לב לשני פרטים חשובים: מה קורה לערכו של משתנה סטטי בין קריאות שונות לפונקציה, ומהי המחרוזת שהפונקציה `f` מקבלת בפועל בקריאה השנייה אליה?",
    explanation:
      "התנהגות התוכנית נקבעת על ידי שני רכיבים מרכזיים: המשתנה הסטטי `x` בתוך הפונקציה `f`, והמצביע `s` שמועבר אליה. בקריאה הראשונה, `f(s)`, המשתנה הסטטי `x` מאותחל ל־5. הפונקציה מדפיסה את התו באינדקס 5 (כלומר `x+y` שהוא `5+0`) מהמחרוזת המקורית, שזהו התו '6'. לאחר ההדפסה, ערכו של `x` יורד ב־2 והופך ל־3, והוא ישמור על ערך זה לקראת הקריאה הבאה.\n\nבקריאה השנייה, `f(s + y)`, שני דברים משתנים. ראשית, המצביע המועבר לפונקציה הוא `s + 1` (כיוון שהמשתנה הגלובלי `y` שווה 1), ולכן הפונקציה רואה את המחרוזת כמתחילה מהתו השני, `\"23456789\"`. שנית, המשתנה הסטטי `x` ממשיך מהערך הקודם שלו, 3, ולא מאותחל מחדש. עכשיו אנחנו צריכים להדפיס את הערך שבאינדקס `x+y`. שימו לב שכאן `y` שווה שוב ל־0, כי מדובר על המשתנה הלוקאלי (ולא הגלובלי). אז, בקיצור, `x+y` שווה ל־`3+0`, ולכן הפונקציה מדפיסה את התו באינדקס 3 מהמחרוזת החדשה שהיא קיבלה, שזהו התו '5'.",
  },
  {
    code: `void print_args_reverse(void *p, void *s) {
    while (p!=s) {
        printf("%s\\n", [[1]] p);
        p = [[2]] p-1;
    }
}

void main(int argc, char *argv[]) {
    print_args_reverse( [[3]] , argv);
}`,
    question:
      "מה יש למלא במקומות הממוספרים 1 עד 3 כדי שהקוד ידפיס את הארגומנטים שהועברו אליו בסדר הפוך (מהאחרון לראשון, ללא שם התוכנית)?",
    answers: [
      "[[1: *(char**)]][[2: (char**)]][[3: argv+argc-1]]",
      "[[1: **(char*)]][[2: (char*)]][[3: *(argv+argc-1)]]",
      "[[1: *(char*)]][[2: (char*)]][[3: *(argv+argc-1)]]",
      "[[1: **(char**)]][[2: (char*)]][[3: argv+argc-1]]",
      "[[1: *(char**)]][[2: (char**)]][[3: *(argv+argc-1)]]",
      "כל התשובות האחרות אינן נכונות",
    ],
    correct: 0,
    hint: "זכרו שמערך הארגומנטים `argv` הוא מסוג `char**`. כדי לעבור עליו בסדר הפוך, עליכם להגדיר מצביע שמתחיל מהאיבר האחרון ומצביע שמסמן את נקודת העצירה. חשבו אילו פעולות המרה (casting) וגישה לזיכרון (dereferencing) נדרשות כדי להדפיס את המחרוזת הנכונה בכל שלב.",
    explanation:
      "בתיבה 3 יש להעביר את המצביע לארגומנט האחרון. מערך הארגומנטים `argv` מכיל `argc` איברים, והאיבר האחרון נמצא באינדקס `argc-1`. הכתובת של איבר זה היא `argv + argc - 1`. נקודת העצירה, `s`, כבר מועברת בתור `argv`, כך שהלולאה תעצור לפני שתעבד את `argv[0]` (שם התוכנית).\n\nבתיבה 2, מדובר בהשלמה פשוטה: אנחנו כבר יודעים שהמצביע `p` הוא למעשה מצביע ל־`char*`, כלומר מסוג `char**`. מאחר שאריתמטיקה על מצביעים אינה אפשרית עם `void*`, יש להמיר את `p` לסוגו המקורי כדי שנוכל להחסיר ממנו אחד ולנוע אחורה במערך. לכן ההשלמה הנכונה היא ההמרה `(char**)`.\n\nבתיבה 1, המטרה היא להדפיס את המחרוזת שמצביע עליה `p`. כאמור, `p` הוא `void*`, אך בפועל הוא מצביע למצביע למחרוזת (`char**`). כדי להגיע למחרוזת עצמה (`char*`), יש להמיר את `p` ל־`char**` ואז לבצע עליו דה־רפרנסינג. בצורה זו נקבל את המחרוזת שאותה נוכל להעביר ל־`printf`. לכן, ההשלמה הנכונה היא `*(char**)`. חשוב לשים לב שלא נכון לעשות `**(char**)p`, כי פעולה כזו תיגש לתו הראשון של המחרוזת (כלומר תביא את הערך של התו הראשון, לדוגמה 'a'), בעוד ש־`%s` ב־`printf` מצפה לקבל כתובת של תחילת מחרוזת, לא תו בודד. בדיוק את זה אנחנו מספקים באמצעות `*(char**)p`.",
  },
];
