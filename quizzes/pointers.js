// עבר בדיקה
const quizData = [
  {
    code: `void main() {
    int a[4][2] = {{1,2},{3,4},{5,6},{7,8}};
    printf("%d %d \\n", *(a[2]+1), a[2][-2]);
}`,
    question: "מהו הפלט של התכנית הבאה?",
    answers: [
      "`6 3`",
      "`4 3`",
      "`4 1`",
      "Segmentation fault",
      "כל התשובות האחרות אינן נכונות",
    ],
    correct: 0,
    hint: "זכרו שבשפת C, גישה לאינדקס במערך היא למעשה אריתמטיקה של מצביעים. בניגוד לשפות כמו פייתון, גישה לאינדקס שלילי אינה מתחילה מסוף המערך, אלא מבצעת חישוב כתובת אחורה בזיכרון.",
    explanation:
      "נתחיל עם הביטוי הראשון `*(a[2]+1)`. אם נדמיין את המערך הדו־מימדי בתור טבלה, אז `a[2]` מחזיר את הכתובת של תחילת השורה השלישית במערך, כלומר  `a[2]` מצביע לאיבר (5).  לפי אריתמטיקת מצביעים, `a[2]+1` מצביע לאיבר השני (6) שבאותה השורה, וכשנפעיל עליו כוכבית, נקבל את הערך `6` עצמו.\n\nאת הביטוי השני `a[2][-2]` אפשר לתרגם ל־`*(a[2] - 2)`. מאחר שהמערך רציף בזיכרון, ביצוע אריתמטיקת מצביעים אחורה מהכתובת של האיבר (5) מביא אותנו לאיברים הקודמים. במקרה שלנו, `a[2]-1` מצביע ל־(4), ו־`a[2]-2` מצביע ל־(3). כשנפעיל על `a[2]-2` כוכבית, נקבל את הערך `3` עצמו.",
  },
  {
    code: `void foo(int n, int* p) {
    if (n <= 0) {
        (*p)++;
        return;
    }

    int a=n;
    foo(n - 1, &a);
    printf("%d ", a);
}

void main() {
    int i = 0;
    foo(3, &i);
}`,
    question: "מהו הפלט של התכנית הבאה?",
    answers: [
      "`2 2 3`",
      "`1 2 3`",
      "`0 1 2 3`",
      "התכנית עוברת קומפילציה אך קיים בה באג זמן ריצה",
      "יתר התשובות אינן נכונות",
    ],
    correct: 0,
    hint: "שימו לב כיצד בכל קריאה רקורסיבית מועברת כתובת של משתנה מקומי חדש. עקבו אחר הערך של המשתנה `a` בכל אחד מהמופעים שעל המחסנית.",
    explanation:
      "הפונקציה `foo` היא רקורסיבית. בכל קריאה, נוצר משתנה מקומי `a` שערכו הוא `n`, והכתובת שלו מועברת לקריאה הרקורסיבית הבאה.\nשרשרת הקריאות היא: הפונקציה `foo(3)` קוראת ל־`foo(2)`, שקוראת ל־`foo(1)`, שקוראת ל־`foo(0)`. בתנאי העצירה בקריאה `foo(0)`, הפקודה `(*p)++` מגדילה את ערך המשתנה שהמצביע `p` מצביע אליו. המצביע `p` מצביע למשתנה `a` מהקריאה הקודמת, `foo(1)`, ולכן ערכו של אותו `a` משתנה מ־1 ל־2.\nההדפסות מתבצעות בסדר הפוך, בזמן החזרה מהרקורסיה. הפונקציה `foo(1)` מדפיסה את המשתנה `a` המקומי שלה, שכעת ערכו 2. הפונקציה `foo(2)` מדפיסה את המשתנה `a` שלה, שערכו נשאר 2. לבסוף, `foo(3)` מדפיסה את המשתנה `a` שלה, שערכו 3. לכן הפלט הוא `2 2 3`.",
  },
  {
    code: `void f(int *pn, int *pm) {
    pm = pn-1;
    *pm = *pn +1;
}

void main() {
    int arr[2] = {4, 2};
    f(arr+1, arr+4);
    printf("%d %d", *arr, *(arr+1));
}`,
    question: "מהו הפלט של תכנית זו?",
    answers: [
      "`3 2`",
      "`4 3`",
      "התכנית לא עוברת קומפילציה",
      "התכנית גורמת לשגיאת זמן ריצה",
      "כל התשובות האחרות אינן נכונות",
    ],
    correct: 0,
    hint: "בשפת C, אין בדיקה אוטומטית של חריגה מגבולות מערך, והתנהגות כזו היא בלתי מוגדרת. עם זאת, שימו לב היטב איזו כתובת מושמת במצביע `pm` לפני שמתבצעת כתיבה לזיכרון.",
    explanation:
      "הפונקציה `f` מקבלת שני מצביעים, `pn` ו־`pm`. בקריאה מהפונקציה `main`, המצביע `pn` מקבל את הכתובת של `arr[1]`, ו־`pm` מקבל את הכתובת `arr+4` (מחוץ לגבולות המערך).\nהשורה הקריטית היא `pm = pn-1;`. פקודה זו משנה את המצביע המקומי `pm` כך שהוא יצביע כעת לכתובת של `arr[0]`. הכתובת המקורית שאליה הצביע (`arr+4`) נזרקת. לאחר מכן, השורה `*pm = *pn + 1;` מבצעת את החישוב: היא לוקחת את הערך שהמצביע `pn` מצביע אליו (`arr[1]`, כלומר 2), מוסיפה לו 1, ומציבה את התוצאה (3) בכתובת שאליה `pm` מצביע כעת, כלומר ב־`arr[0]`. המערך `arr` הופך להיות `{3, 2}`, וההדפסה מציגה `3 2`.",
  },
  {
    code: `void f(int *pn, int *pm) {
    pn = pm;

    if (*pm)
        *pm = 1;
    else
        *pm = -1;
}

void main() {
    int n = 2, m = 0;
    int *pn = &n, *pm = &m;

    f(pn, pm);
    printf("%d %d", *pn, *pm);
}`,
    question: "מהו הפלט של התכנית הבאה?",
    answers: [
      "`2 -1`",
      "כל התשובות האחרות אינן נכונות",
      "`2 1`",
      "`1 1`",
      "`-1 -1`",
    ],
    correct: 0,
    hint: "בשפת C, הערך 0 נחשב ל'שקר' בתנאים לוגיים, וכל ערך אחר שאינו אפס נחשב ל'אמת'. כמו כן, שימו לב שהשמה למצביע בתוך פונקציה משפיעה רק על ההעתק המקומי של המצביע.",
    explanation:
      "בפונקציה `main`, המשתנה `n` מקבל את הערך 2, ו־`m` את הערך 0. המצביע `pn` מאותחל להצביע על `n`, והמצביע `pm` מאותחל להצביע על `m`.\nכאשר הפונקציה `f` נקראת, היא מקבלת העתקים של כתובות אלו. השורה `pn = pm;` בתוך הפונקציה `f` משנה רק את ההעתק המקומי של `pn`. היא אינה משפיעה על המצביע `pn` המקורי בפונקציה `main`, שממשיך להצביע על `n`. התנאי `if (*pm)` בודק את הערך של `m` (שהוא 0), שנחשב לשקר ב־C. לכן, מתבצעת פקודת ה־`else`, והערך בכתובת של `m` משתנה ל־1-.\nבסיום, פקודת ההדפסה ב־`main` מדפיסה את הערכים דרך המצביעים המקוריים: `*pn` עדיין מצביע ל־`n` שערכו 2, ו־`*pm` מצביע ל־`m` שערכו כעת 1-. לכן, הפלט הוא `2 -1`.",
  },
  {
    code: `void fun(int **a) {
    *a = (int*)malloc(sizeof(int));
}

void main() {
    
    int **p = NULL;
    fun(p);
    
    **p = 6;
    printf("%d\\n", **p);
}`,
    question: "מה תהיה התוצאה של הרצת התכנית הבאה?",
    answers: [
      "`6`",
      "תתקבל שגיאה בזמן ריצה",
      "כל התשובות האחרות אינן נכונות",
      "`0`",
      "התוכנית אינה מתקמפלת",
    ],
    correct: 1,
    hint: "בזמן קריאה לפונקציה, המשתנים מועברים אליה באמצעות העתקת ערכם (pass-by-value). שימו לב מהו הערך של המצביע `p` כאשר הוא מועבר לפונקציה `fun`.",
    explanation:
      "בפונקציה `main`, המצביע הכפול `p` מאותחל לערך `NULL`. לאחר מכן, הפונקציה `fun` נקראת עם `p` כארגומנט. מכיוון ששפת C מעבירה ארגומנטים 'לפי ערך' (by value), המצביע `a` בתוך הפונקציה `fun` מקבל העתק של `p`, כלומר גם `a` מקבל את הערך `NULL`.\n\nהבעיה מתרחשת בשורה `*a = (int*)malloc(sizeof(int));` שבתוך הפונקציה `fun`. בשורה זו, התכנית מנסה לבצע פעולת dereference על המצביע `a`, כלומר לגשת לכתובת הזיכרון ש־`a` מחזיק כדי לשנות את תוכנה. מכיוון ש־`a` הוא `NULL`, ניסיון זה הוא למעשה ניסיון לכתוב לכתובת זיכרון לא חוקית (כתובת 0), פעולה שמובילה לקריסת התכנית, כלומר לשגיאת זמן ריצה.",
  },
  {
    code: `void f(int *ptr) {

    if (*ptr / 10 == 0)
        return;
    
    ptr[0] /= 10;
    f(ptr);
}

void main() {

    static int x = 100;
    f(&x);

    printf("%d", x);
}`,
    question: "מהו הפלט של תכנית זו?",
    answers: [
      "`1`",
      "`10`",
      "`100`",
      "התוכנית תעוף בזמן ריצה",
      "התוכנית לא תעבור קומפילציה",
      "אף תשובה מבין התשובות האחרות אינה נכונה",
    ],
    correct: 0,
    hint: "הפונקציה `f` היא רקורסיבית. שימו לב שהיא משנה את ערכו של המשתנה המקורי שהועבר אליה, וכיצד תנאי העצירה של הרקורסיה תלוי בערך זה.\n\nאל תיבהלו מההופעה של `ptr[i]` — זה אולי נראה כמו גישה למערך, אבל `ptr` לא חייב להצביע על מערך. זה פשוט קיצור של `*(ptr + i)`, כלומר אריתמטיקה של מצביעים.\nאז במקרה שלנו, ש־i = 0, למה שווה `ptr[0]`?\nהם סתם כתבו את זה כדי להפחיד, אבל זה הרבה יותר פשוט ממה שזה נראה.",
    explanation:
      "הפונקציה `f` היא פונקציה רקורסיבית שמקבלת מצביע למשתנה. באופן כללי, הפונקציה מחלקת את ערך המשתנה ב־10 (בחלוקת שלמים) שוב ושוב, עד שהערך הופך לקטן מ־10, כלומר עד שתוצאת החלוקה ב־10 היא 0.\nבמקרה זה, המשתנה `x` מתחיל עם הערך 100. בקריאה הראשונה ל־`f`, התנאי `100 / 10 == 0` הוא שקרי, ולכן `x` משתנה ל־10 ומתבצעת קריאה רקורסיבית. בקריאה השנייה, התנאי `10 / 10 == 0` עדיין שקרי, ו־`x` משתנה ל־1. בקריאה השלישית, התנאי `1 / 10 == 0` הוא אמת, והרקורסיה נעצרת.\nלאחר סיום כל הקריאות, הערך הסופי של `x` הוא 1. פקודת ההדפסה בפונקציה `main` תדפיס ערך זה.",
  },
  {
    code: `typedef struct {
    char *a;
    char *b;
} t;

void f1(t s) {
    s.a = "C";
    s.b = "D";
}

void f2(t *p) {
    p->a = "E";
    p->b = "F";
}

void main() {
    static t s = {"A", "B"};
    printf("%s %s ", s.a, s.b);

    f1(s);
    printf("%s %s ", s.a, s.b);
    
    f2(&s);
    printf("%s %s\\n", s.a, s.b);
}`,
    question: "מהו הפלט של התכנית הבאה?",
    answers: [
      "`A B A B E F`",
      "כל התשובות האחרות אינן נכונות",
      "`A B C D C D`",
      "`A B C D E F`",
      "`A B A B A B`",
    ],
    correct: 0,
    hint: "שימו לב להבדל המהותי בין העברת מבנה לפונקציה לפי ערך (pass-by-value), כפי שקורה ב־`f1`, לבין העברתו לפי כתובת (pass-by-reference), כפי שקורה ב־`f2`.",
    explanation:
      "הקוד מדגים את ההבדל בין העברת מבנה 'לפי ערך' לעומת 'לפי כתובת'.\nההדפסה הראשונה מציגה את הערכים ההתחלתיים של המבנה `s`, שהם `A B`. לאחר מכן, הפונקציה `f1` נקראת עם `s` כפרמטר. מכיוון שהמבנה מועבר 'לפי ערך', `f1` מקבלת ועובדת על העתק בלבד. השינויים שהיא מבצעת אינם משפיעים על המבנה `s` המקורי בפונקציה `main`. לכן, ההדפסה השנייה תוציא שוב `A B`.\nהפונקציה `f2`, לעומת זאת, מקבלת מצביע ל־`s` (כלומר, 'לפי כתובת'). כתוצאה מכך, השינויים `p->a = \"E\";` ו־`p->b = \"F\";` מתבצעים ישירות על המבנה המקורי `s`. לכן, ההדפסה השלישית והאחרונה תציג את הערכים המעודכנים, `E F`. הפלט המלא הוא שרשור של שלוש ההדפסות.",
  },
  {
    code: `void allocDoublePtr(unsigned int num, double [[1]] res) {

    [[2]] = ([[3]])malloc(num * sizeof([[4]]));

    if (![[5]]) {
        printf("Allocation error!\\n");
        exit(-1);
    }
}`,
    question:
      "מה יש למלא במקומות הממוספרים 1 עד 5 כדי שהפונקציה, המיועדת להקצות מערך של מצביעים ל־`double`, תבצע את הדרוש?",
    answers: [
      "[[1: ***]][[2: *res]][[3: double**]][[4: double*]][[5: *res]]",
      "[[1: **]][[2: *res]][[3: double**]][[4: double*]][[5: res]]",
      "[[1: ***]][[2: res]][[3: double**]][[4: double*]][[5: res]]",
      "[[1: **]][[2: *res]][[3: double**]][[4: double**]][[5: *res]]",
      "[[1: ***]][[2: *res]][[3: double*]][[4: double*]][[5: res]]",
      "כל התשובות האחרות אינן נכונות",
    ],
    correct: 0,
    hint: "כן, אני יודע שאיריס אמרה שלא יהיו שלוש כוכביות במבחן, אבל זו שאלה טובה, והקטע עם השלוש כוכביות ממש קטן (רק בתיבה 1). אז אם אתם מחפשים רמז: בתיבה 1 צריך לשים `***`.\nלגבי שאר התיבות: חשבו מהו הטיפוס של כל איבר במערך שאתם מקצים, ומה הטיפוס של מצביע למערך כזה.",
    explanation:
      "נתחיל עם החלק הקל. בתיבה הרביעית אנחנו צריכים לכתוב את הגודל של כל אחד מהתאים במערך. בשאלה מבקשים מאיתנו להקצות מערך של מצביעים ל־`double`, ולכן די ברור שנצטרך לכתוב שם `double*`.\nכזכור, `malloc` מחזירה מצביע ל־`void`, ואז אנחנו צריכים לבצע את ההמרה לסוג שאליו אנחנו מצפים. איזה סוג בעצם מוחזר מההקצאה? אנחנו מקצים מערך שבו כל תא הוא `double*`, ולכן הכתובת שמתקבלת מ־`malloc` מצביעה על התחלה של מערך כזה — כלומר, היא מסוג `double**`. אז זה מה שצריך למלא בתיבה השלישית.\n\nעכשיו נעבור לחלק היותר מסובך: אנחנו רוצים להעביר את התוצאה דרך הפרמטר `res` כדי שהפונקציה תוכל להחזיר את ההקצאה. נתחיל רגע באופן כללי: אם יש לי משתנה מסוג ברווז ב־main ואני רוצה שהפונקציה תשנה אותו, אני שולח את הכתובת שלו — כלומר, הפונקציה מקבלת משתנה מסוג ברווז כוכבית. בפשטות: הוספנו כוכבית לסוג המשתנה. במקרה שלנו, המשתנה של ה־main הוא מסוג `double**`, אז אם אנחנו רוצים שהפונקציה תשנה אותו — נשלח את הכתובת שלו, כלומר פשוט נוסיף עוד כוכבית, ונקבל `double***`. לכן בתיבה 1 צריך למלא `***`.\n\nלגבי התיבות 2 ו־5: אלו המקומות שבהם אנחנו ניגשים מהפונקציה אל המצביע המקורי ששמרנו ב־`res` שנמצא ב־main — גם כדי להציב בו ערך חדש (בתיבה 2) וגם כדי לבדוק אם ההקצאה הצליחה (בתיבה 5). בשני המקרים אנחנו עושים זאת בעזרת `*res`, ולכן זה מה שנכתוב בשתי התיבות האלה.",
  },
  {
    code: `typedef struct student {
    int grade;
    char *name;
} Student;

void Alloc(Student*** a, int *size) {
    *a = ([[1]])malloc(*size * sizeof([[2]]));
}`,
    question:
      "אנו רוצים לממש פונקציה שמקצה זיכרון למערך של מצביעים לסטודנטים. הפונקציה אינה מחזירה ערך, אלא מעדכנת את `arr` דרך פרמטר פלט `a`. מה יש למלא בתיבות 1 ו־2 כדי לבצע את ההקצאה באופן תקין?",
    answers: [
      "[[1: Student**]][[2: Student*]]",
      "[[1: Student**]][[2: Student**]]",
      "[[1: Student*]][[2: Student*]]",
      "[[1: Student*]][[2: Student]]",
      "יותר מתשובה אחת נכונה",
      "כל האפשרויות שגויות",
    ],
    correct: 0,
    hint: "כן, אני יודע שאיריס אמרה שלא יהיו שלוש כוכביות במבחן, אבל זו שאלה טובה, והקטע עם השלוש כוכביות ממש קטן.\n\nלגבי הרמז, חשבו על שני דברים: מהו הטיפוס של המשתנה שאליו נכנסת תוצאת ההקצאה (`*a`)? זהו הטיפוס שצריך להופיע ב־`cast`. שנית, מהו הטיפוס של כל איבר במערך שאנחנו רוצים ליצור? זהו הטיפוס שצריך להופיע בתוך `sizeof`.",
    explanation:
      "כדי שהפונקציה תעדכן את המצביע `arr` שנמצא בפונקציה הקוראת, עליה לקבל את כתובתו. מכיוון ש־`arr` הוא `Student**`, הפרמטר `a` הוא `Student***`.\n\nבתיבה 2, עלינו לציין את גודל האיבר הבודד במערך שאנו מקצים. מכיוון שאנו מקצים מערך של מצביעים לסטודנטים, כל איבר הוא מסוג `Student*`. לכן, יש למלא `Student*`.\n\nבתיבה 1, עלינו לבצע המרה (`cast`) לערך המוחזר מ־`malloc`. הטיפוס של ההמרה חייב להיות זהה לטיפוס של המשתנה שמקבל את ההקצאה, שהוא `*a`. מכיוון ש־`a` הוא `Student***`, אז `*a` הוא `Student**`. לכן, ההמרה הנכונה היא `(Student**)`.",
  },
];
