// quizzes/pointers.js
const quizData = [
  {
    code: 'void main()\n{\n    int a[4][2] = {{1,2},{3,4},{5,6},{7,8}};\n    printf("%d %d \\n", *(a[2]+1), a[2][-2]);\n}',
    question: "מהו הפלט של התכנית הבאה?",
    answers: [
      "6 3",
      "4 3",
      "4 1",
      "Segmentation fault",
      "כל התשובות האחרות אינן נכונות",
    ],
    correct: 0,
    hint: "זכרו שבשפת C, גישה לאינדקס במערך היא למעשה אריתמטיקה של מצביעים. בניגוד לשפות כמו פייתון, גישה לאינדקס שלילי אינה מתחילה מסוף המערך, אלא מבצעת חישוב כתובת אחורה בזיכרון.",
    explanation:
      "הביטוי `*(a[2]+1)` ניגש לשורה השלישית במערך, `a[2]`, המכילה `{5, 6}`. `a[2]` מצביע לאיבר הראשון (5), ולכן `a[2]+1` מצביע לאיבר השני (6). פעולת ה־dereference, `*`, מחזירה את הערך `6`.\nהביטוי `a[2][-2]` מתורגם ל־`*(a[2] - 2)`. מאחר שהמערך רציף בזיכרון, ביצוע אריתמטיקת מצביעים אחורה מהכתובת של `a[2][0]` (שערכו 5) מביא אותנו לאיברים הקודמים. `a[2]-1` מצביע ל־`a[1][1]` (ערך 4), ו־`a[2]-2` מצביע ל־`a[1][0]` (ערך 3). לכן הביטוי מחזיר 3. הפלט הכולל הוא `6 3`.",
  },
  {
    code: 'void foo(int n, int* p) {\n    if (n <= 0) {\n        (*p)++;\n        return;\n    }\n\n    int a=n;\n    foo(n - 1, &a);\n    printf("%d ", a);\n}\n\nvoid main() {\n    int i = 0;\n    foo(3, &i);\n}',
    question: "מהו הפלט של התכנית הבאה?",
    answers: [
      "2 2 3",
      "1 2 3",
      "0 1 2 3",
      "התכנית עוברת קומפילציה אך קיים בה באג זמן ריצה",
      "יתר התשובות אינן נכונות",
    ],
    correct: 0,
    hint: "שימו לב כיצד בכל קריאה רקורסיבית מועברת כתובת של משתנה מקומי חדש. עקבו אחר הערך של המשתנה `a` בכל מסגרת מחסנית (stack frame) של הפונקציה.",
    explanation:
      "הפונקציה `foo` היא רקורסיבית. בכל קריאה, נוצר משתנה מקומי `a` שערכו הוא `n`, והכתובת שלו מועברת לקריאה הרקורסיבית הבאה.\nשרשרת הקריאות היא: הפונקציה `foo(3)` קוראת ל־`foo(2)`, שקוראת ל־`foo(1)`, שקוראת ל־`foo(0)`. בתנאי העצירה בקריאה `foo(0)`, הפקודה `(*p)++` מגדילה את ערך המשתנה שהמצביע `p` מצביע אליו. המצביע `p` מצביע למשתנה `a` מהקריאה הקודמת, `foo(1)`, ולכן ערכו של אותו `a` משתנה מ־1 ל־2.\nההדפסות מתבצעות בסדר הפוך, בזמן החזרה מהרקורסיה. הפונקציה `foo(1)` מדפיסה את המשתנה `a` המקומי שלה, שכעת ערכו 2. הפונקציה `foo(2)` מדפיסה את המשתנה `a` שלה, שערכו נשאר 2. לבסוף, `foo(3)` מדפיסה את המשתנה `a` שלה, שערכו 3. לכן הפלט הוא `2 2 3`.",
  },
  {
    code: '#include <stdio.h>\n\nvoid f(int *pn, int *pm)\n{\n    pm = pn-1;\n    *pm = *pn +1;\n}\n\nint main()\n{\n    int arr[2] = { 4, 2 };\n    f(arr+1, arr+4);\n    printf("%d %d", *arr, *(arr+1));\n    return 0;\n}',
    question: "מהו הפלט של תכנית זו?",
    answers: [
      "3 2",
      "4 3",
      "התכנית לא עוברת קומפילציה",
      "התכנית גורמת לשגיאת זמן ריצה",
      "כל התשובות האחרות אינן נכונות",
    ],
    correct: 0,
    hint: "בשפת C, אין בדיקה אוטומטית של חריגה מגבולות מערך, והתנהגות כזו היא בלתי מוגדרת. עם זאת, שימו לב היטב איזו כתובת מושמת במצביע `pm` לפני שמתבצעת כתיבה לזיכרון.",
    explanation:
      "הפונקציה `f` מקבלת שני מצביעים, `pn` ו־`pm`. בקריאה מהפונקציה `main`, המצביע `pn` מקבל את הכתובת של `arr[1]`, ו־`pm` מקבל את הכתובת `arr+4` (מחוץ לגבולות המערך).\nהשורה הקריטית היא `pm = pn-1;`. פקודה זו משנה את המצביע המקומי `pm` כך שהוא יצביע כעת לכתובת של `arr[0]`. הכתובת המקורית שאליה הצביע (`arr+4`) נזרקת. לאחר מכן, השורה `*pm = *pn + 1;` מבצעת את החישוב: היא לוקחת את הערך שהמצביע `pn` מצביע אליו (`arr[1]`, כלומר 2), מוסיפה לו 1, ומציבה את התוצאה (3) בכתובת שאליה `pm` מצביע כעת, כלומר ב־`arr[0]`. המערך `arr` הופך להיות `{3, 2}`, וההדפסה מציגה `3 2`.",
  },
  {
    code: '#include <stdio.h>\n\nvoid f(int *pn, int *pm)\n{\n    pn = pm;\n    if (*pm)\n        *pm = 1;\n    else\n        *pm = -1;\n}\n\nint main()\n{\n    int n = 2, m = 0;\n    int *pn = &n, *pm = &m;\n\n    f(pn, pm);\n    printf("%d %d", *pn, *pm);\n    return 0;\n}',
    question: "מהו הפלט של התכנית הבאה?",
    answers: ["-1 -1", "כל התשובות האחרות אינן נכונות", "2 1", "1 1", "2 -1"],
    correct: 4,
    hint: "בשפת C, הערך 0 נחשב ל'שקר' בתנאים לוגיים, וכל ערך אחר שאינו אפס נחשב ל'אמת'. כמו כן, שימו לב שהשמה למצביע בתוך פונקציה משפיעה רק על ההעתק המקומי של המצביע.",
    explanation:
      "בפונקציה `main`, המשתנה `n` מקבל את הערך 2, ו־`m` את הערך 0. המצביע `pn` מאותחל להצביע על `n`, והמצביע `pm` מאותחל להצביע על `m`.\nכאשר הפונקציה `f` נקראת, היא מקבלת העתקים של כתובות אלו. השורה `pn = pm;` בתוך הפונקציה `f` משנה רק את ההעתק המקומי של `pn`. היא אינה משפיעה על המצביע `pn` המקורי בפונקציה `main`, שממשיך להצביע על `n`. התנאי `if (*pm)` בודק את הערך של `m` (שהוא 0), שנחשב לשקר ב־C. לכן, מתבצעת פקודת ה־`else`, והערך בכתובת של `m` משתנה ל־-1.\nבסיום, פקודת ההדפסה ב־`main` מדפיסה את הערכים דרך המצביעים המקוריים: `*pn` עדיין מצביע ל־`n` שערכו 2, ו־`*pm` מצביע ל־`m` שערכו כעת -1. לכן, הפלט הוא `2 -1`.",
  },
  {
    code: 'void fun(int **a)\n{\n    *a = (int*)malloc(sizeof(int));\n}\n\nvoid main()\n{\n    int **p = NULL;\n    fun(p);\n    **p = 6;\n    printf("%d\\n", **p);\n}',
    question: "מה תהיה התוצאה של הרצת התכנית הבאה?",
    answers: [
      "6",
      "תתקבל שגיאה בזמן ריצה",
      "כל התשובות האחרות אינן נכונות",
      "0",
      "התוכנית אינה מתקמפלת",
    ],
    correct: 1,
    hint: "בזמן קריאה לפונקציה, המשתנים מועברים אליה באמצעות העתקת ערכם (pass-by-value). שימו לב מהו הערך של המצביע `p` כאשר הוא מועבר לפונקציה `fun`.",
    explanation:
      "בפונקציה `main`, המצביע הכפול `p` מאותחל לערך `NULL`. לאחר מכן, הפונקציה `fun` נקראת עם `p` כארגומנט. מכיוון ששפת C מעבירה ארגומנטים 'לפי ערך' (by value), המצביע `a` בתוך הפונקציה `fun` מקבל העתק של `p`, כלומר גם `a` מקבל את הערך `NULL`.\n\nהבעיה מתרחשת בשורה `*a = (int*)malloc(sizeof(int));` בתוך הפונקציה `fun`. בשורה זו, התכנית מנסה לבצע פעולת dereference על המצביע `a`, כלומר לגשת לכתובת הזיכרון ש־`a` מחזיק כדי לשנות את תוכנה. מכיוון ש־`a` הוא `NULL`, ניסיון זה הוא למעשה ניסיון לכתוב לכתובת זיכרון לא חוקית (כתובת 0), פעולה שברוב מערכות ההפעלה המודרניות תוביל לקריסת התכנית, כלומר לשגיאת זמן ריצה.",
  },
  {
    code: 'void f(int *ptr)\n{\n    if (*ptr / 10 == 0)\n        return;\n    ptr[0] /= 10;\n    f(ptr);\n}\n\nvoid main()\n{\n    static int x = 100;\n    f(&x);\n    printf("%d", x);\n}',
    question: "מהו הפלט של תכנית זו?",
    answers: [
      "1",
      "10",
      "100",
      "התוכנית תעוף בזמן ריצה.",
      "התוכנית לא תעבור קומפילציה.",
      "אף תשובה מבין התשובות האחרות אינה נכונה.",
    ],
    correct: 0,
    hint: "הפונקציה `f` היא רקורסיבית. שימו לב שהיא משנה את ערכו של המשתנה המקורי שהועבר אליה, וכיצד תנאי העצירה של הרקורסיה תלוי בערך זה.",
    explanation:
      "הפונקציה `f` היא פונקציה רקורסיבית שמקבלת מצביע למשתנה. באופן כללי, הפונקציה מחלקת את ערך המשתנה ב־10 (בחלוקת שלמים) שוב ושוב, עד שהערך הופך לקטן מ־10, כלומר עד שתוצאת החלוקה ב־10 היא 0.\nבמקרה זה, המשתנה `x` מתחיל עם הערך 100. בקריאה הראשונה ל־`f`, התנאי `100 / 10 == 0` הוא שקרי, ולכן `x` משתנה ל־10 ומתבצעת קריאה רקורסיבית. בקריאה השנייה, התנאי `10 / 10 == 0` עדיין שקרי, ו־`x` משתנה ל־1. בקריאה השלישית, התנאי `1 / 10 == 0` הוא אמת, והרקורסיה נעצרת.\nלאחר סיום כל הקריאות, הערך הסופי של `x` הוא 1. פקודת ההדפסה בפונקציה `main` תדפיס ערך זה.",
  },
  {
    code: 'typedef struct\n{\n    char *a;\n    char *b;\n} t;\n\nvoid f1(t s)\n{\n    s.a = "C";\n    s.b = "D";\n}\n\nvoid f2(t *p)\n{\n    p->a = "E";\n    p->b = "F";\n}\n\nvoid main()\n{\n    static t s = {"A", "B"};\n    printf("%s %s ", s.a, s.b);\n    f1(s);\n    printf("%s %s ", s.a, s.b);\n    f2(&s);\n    printf("%s %s\\n", s.a, s.b);\n}',
    question: "מהו הפלט של התכנית הבאה?",
    answers: [
      "A B A B E F",
      "כל התשובות האחרות אינן נכונות.",
      "A B C D C D",
      "A B C D E F",
      "A B A B A B",
    ],
    correct: 0,
    hint: "שימו לב להבדל המהותי בין העברת מבנה (`struct`) לפונקציה לפי ערך (pass-by-value), כפי שקורה ב־`f1`, לבין העברתו לפי כתובת (pass-by-reference), כפי שקורה ב־`f2`.",
    explanation:
      "הקוד מדגים את ההבדל בין העברת מבנה (struct) 'לפי ערך' לעומת 'לפי כתובת'.\nההדפסה הראשונה מציגה את הערכים ההתחלתיים של המבנה `s`, שהם `A B`. לאחר מכן, הפונקציה `f1` נקראת עם `s` כפרמטר. מכיוון שהמבנה מועבר 'לפי ערך', `f1` מקבלת ועובדת על העתק בלבד. השינויים שהיא מבצעת אינם משפיעים על המבנה `s` המקורי בפונקציה `main`. לכן, ההדפסה השנייה תוציא שוב `A B`.\nהפונקציה `f2`, לעומת זאת, מקבלת מצביע ל־`s` (כלומר, 'לפי כתובת'). כתוצאה מכך, השינויים `p->a = \"E\";` ו־`p->b = \"F\";` מתבצעים ישירות על המבנה המקורי `s`. לכן, ההדפסה השלישית והאחרונה תציג את הערכים המעודכנים, `E F`. הפלט המלא הוא שרשור של שלוש ההדפסות.",
  },
  {
    code: 'void allocateDoublePtrArray(unsigned int num, double [[1]] res)\n{\n    [[2]] = ([[3]])malloc(num * sizeof([[4]]));\n\n    if (![[5]])\n    {\n        printf("Allocation error!\\n");\n        exit(-1);\n    }\n}',
    question:
      "מה יש למלא במקומות הממוספרים 1 עד 5 כדי שהפונקציה, המיועדת להקצות מערך של מצביעים ל־`double`, תבצע את הדרוש?",
    answers: [
      "[[1: ***]][[2: *res]][[3: double**]][[4: double*]][[5: *res]]",
      "[[1: **]][[2: *res]][[3: double**]][[4: double*]][[5: res]]",
      "[[1: ***]][[2: res]][[3: double**]][[4: double*]][[5: res]]",
      "[[1: **]][[2: *res]][[3: double**]][[4: double**]][[5: *res]]",
      "[[1: ***]][[2: *res]][[3: double*]][[4: double*]][[5: res]]",
      "כל התשובות האחרות אינן נכונות",
    ],
    correct: 0,
    hint: "כן, אני יודע. איריס אמרה שלא יהיה יותר משתי כוכביות במבחן, אבל בכל זאת שמתי את זה כאן כי זה באמת תרגיל טוב שממחיש את נושא הפוינטרים\nלגבי הרמז: כדי שהפונקציה תשנה את המצביע שהועבר אליה מהפונקציה הקוראת, יש להעביר מצביע לאותו מצביע. חשבו מהו הטיפוס של כל איבר במערך שאתם מקצים, ומהו טיפוס המצביע למערך כזה...",
    explanation:
      "המטרה היא להקצות מערך של מצביעים ל־`double` ולהחזיר אותו דרך הפרמטר `res`. כדי שהפונקציה תוכל לשנות את המצביע המקורי (שיהיה מסוג `double**`), יש להעביר את כתובתו. לכן, הפרמטר `res` חייב להיות `double***`, ובתיבה 1 יש למלא `***`.\n\nההקצאה עצמה צריכה להישמר במצביע המקורי, ולכן ניגש אליו באמצעות `dereference: *res = ...`. לכן בתיבה 2 יש למלא `*res`. אנו מקצים מערך של מצביעים ל־`double`, כלומר כל איבר במערך הוא `double*`. לכן בתיבה 4 יש למלא `double*`.\n\nהפונקציה `malloc` מחזירה `void*`, ויש לבצע `cast` לטיפוס של המשתנה שמקבל את הערך, שהוא `double**`. לכן בתיבה 3 יש למלא `double**`. לבסוף, יש לבדוק אם ההקצאה הצליחה על ידי בדיקת המשתנה שקיבל את הכתובת, שהוא `*res`. לכן בתיבה 5 יש למלא `*res`.",
  },
  {
    code: "typedef struct student\n{\n    int grade;\n    char *name;\n} Student;\n\n\nvoid Alloc1(Student*** a, int *size)\n{\n    a = (Student***)malloc(*size * sizeof(Student**));\n}\n\nvoid Alloc2(Student*** a, int *size)\n{\n    **a = (Student*)malloc(*size * sizeof(Student**));\n}\n\nvoid Alloc3(Student*** a, int *size)\n{\n    *a = (Student**)malloc(*size * sizeof(Student*));\n}\n\nvoid Alloc4(Student*** a, int *size)\n{\n    *a = (Student*)malloc(*size * sizeof(Student**));\n}",
    question:
      "בהינתן מבנה הנתונים `Student` והפונקציות משמאל, ובהינתן המשתנה `Student **arr;`, איזו מהפונקציות `Alloc` תקצה עבור `arr` מערך של מצביעים לסטודנטים בגודל `size` באופן תקין?",
    answers: [
      "Alloc3",
      "Alloc1",
      "Alloc2",
      "Alloc4",
      "אף אחת מהפונקציות",
      "שתיים או יותר מהפונקציות",
    ],
    correct: 0,
    hint: "כדי לשנות משתנה שהועבר לפונקציה, יש להעביר את כתובתו. חשבו מהו הטיפוס של `arr`, מהו הטיפוס של כתובתו, ומהו טיפוס הנתונים שכל איבר במערך המוקצה אמור להכיל.",
    explanation:
      "כדי להקצות זיכרון עבור המשתנה `arr` (שהוא מסוג `Student**`) ולהחזיר את הכתובת דרך פרמטר, הפונקציה צריכה לקבל את כתובתו של `arr`, כלומר פרמטר מסוג `Student***`. כל הפונקציות עומדות בתנאי זה.\nהשורה המבצעת את ההקצאה צריכה להציב את הכתובת החדשה בתוך `arr` המקורי, ולכן עליה לבצע השמה ל־`*a`. אנו מקצים מערך של מצביעים לסטודנטים, לכן כל איבר במערך הוא מסוג `Student*`, וגודל ההקצאה הוא `*size * sizeof(Student*)`.\nהפונקציה `malloc` מחזירה `void*`, ויש להמיר את הכתובת לטיפוס של `*a`, שהוא `Student**`. הפונקציה היחידה שמבצעת את כל השלבים הללו נכונה היא `Alloc3`, עם השורה: `*a = (Student**)malloc(*size * sizeof(Student*));`.",
  },
];
