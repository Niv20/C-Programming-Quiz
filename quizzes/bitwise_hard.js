const quizData = [
  {
    code: "",
    question:
      "נתון משתנה `x` מטיפוס `unsigned short` שגודלו שני בתים וארוזים בו שלושה ערכים על פי המבנה הבא: `XXXXXYYYYYYZZZZZ`. מעוניינים להחליף בין חמשת הביטים `XXXXX` לששת הביטים `YYYYYY` כך שיתקבל המבנה `YYYYYYXXXXXZZZZZZ`. איזו מהפקודות הבאות תבצע את הפעולה?",
    answers: [
      "`x = ((x>>11)<<5) | ((x>>5)<<10) | (x & 0x1F);`",
      "`x = ((x>>11)<<5) | (((x>>5) & 0x3F)<<10) | (x & 0x1F);`",
      "`x = ((x & 0xF800) >> 5) | ((x & 0x07E0) << 6) | (x & 0x1F);`",
      "`x = ((x>>11)<<5) | (((x>>5) & 0x1F)<<10) | (x & 0x1F);`",
      "`x = ((x>>11)<<5) | (((x>>5) & 0x3F)<<10) & (x & 0x1F);`",
      "אף אחת מהתשובות אינה נכונה",
    ],
    correct: 1,
    hint: "האתגר הוא לבודד את קבוצת הביטים האמצעית (`YYYYYY`). פעולת הזזה ימינה (`>>`) כדי להסיר את הביטים הנמוכים תשאיר גם את הביטים הגבוהים. כיצד ניתן להסיר את הביטים הגבוהים המיותרים לפני שמזיזים את הקבוצה חזרה שמאלה?",
    explanation:
      "הפתרון הנכון דורש בידוד, הזזה, ואיחוד של כל אחד משלושת חלקי המידע בנפרד. נפרק את הביטוי הנכון:\n\n1.  **`(x & 0x1F)`**: חלק זה מבודד את 5 הביטים הנמוכים (`ZZZZZ`) ומשאיר אותם במקומם.\n2.  **`((x>>11)<<5)`**: חלק זה מבודד את 5 הביטים הגבוהים (`XXXXX`) על ידי הזזתם 11 מקומות ימינה (מה שמשאיר `00...XXXXX`), ואז מזיז אותם 5 מקומות שמאלה כדי למקם אותם במקום החדש (ביטים 9 עד 5).\n3.  **`(((x>>5) & 0x3F)<<10)`**: זהו החלק המורכב. `(x>>5)` מזיז את הביטים הרצויים (`YYYYYY`) לקצה הימני, אך משאיר את `XXXXX` לפניהם. פעולת ה-`& 0x3F` חיונית כדי למחוק את ביטי ה-`XXXXX` ולהשאיר רק את 6 הביטים של `YYYYYY`. לבסוף, `<<10` מזיז אותם למקומם החדש והרצוי (ביטים 15 עד 10).\n\nאיחוד שלושת החלקים עם `OR` נותן את התוצאה המבוקשת.",
  },
  {
    code: "",
    question:
      "מעוניינים לקחת `unsigned short int` בשם `num` ולשנות את הבית ה-`least significant` שלו כך שארבעת הביטים ה-`most significant` של בית זה יהיו `C` (בבסיס 16), בעוד שאר הביטים ישמרו על ערכם המקורי. איזו מהשורות הבאות תבצע את המשימה?",
    answers: [
      "`num = ((num & 0xFFCF) & 0x00C0);`",
      "`num = ((num & 0x00C0) & 0x00F0);`",
      "`num = ((num & 0xFF0F) & 0x00C0);`",
      "`num = ((num & 0x00C0) & 0xFF0F);`",
      "כל התשובות האחרות אינן נכונות",
    ],
    correct: 4,
    hint: "הפעולה הנדרשת מורכבת משני שלבים: ראשית, איפוס הביטים שאותם רוצים לשנות (מבלי לפגוע באחרים), ושנית, 'הדלקת' הביטים החדשים במיקומם. איזו פעולה בינארית משמשת לאיפוס, ואיזו להדלקה?",
    explanation:
      "הדרך הנכונה לבצע את המשימה היא בשני שלבים: איפוס ארבעת הביטים הרלוונטיים, ולאחר מכן קביעת הערך החדש שלהם. הפקודה הנכונה אמורה להיות `num = (num & 0xFF0F) | 0x00C0;`. אף אחת מהתשובות המוצגות אינה מבצעת זאת.\n\nרוב התשובות המוצעות משתמשות בפעולת `AND` כפולה. פעולת `AND` יכולה רק לכבות ביטים, ולכן לא ניתן להשתמש בה כדי לקבוע את הערך החדש `C`. לדוגמה, שימוש בביטוי `& 0x00C0` בסוף הפעולה יאפס את כל הביטים במספר פרט לאלו שדולקים במסכה, וזו אינה המטרה. בתשובה אחרת, השימוש במסכה `& 0xFF0F` מאפס נכונה את ארבעת הביטים הרלוונטיים, אך לאחריו לא מתבצעת פעולת ה־`OR` הנדרשת כדי לקבוע את הערך החדש `C`.",
  },
  {
    code: `void printInBinary1(char n)
{
    char mask = 0x80;
    while (mask)
    {
        if (n & mask)
            printf("1");
        else
            printf("0");
        mask >>= 1;
    }
}

void printInBinary2(char n)
{
    while (n)
    {
        if (n & 128)
            printf("1");
        else
            printf("0");
        n <<= 1;
    }
}

void printInBinary3(char n)
{
    int i = 0;
    while (n)
    {
        if (n & 128)
            printf("1");
        else
            printf("0");
        n <<= 1;
        i++;
    }
    for ( ; i < 8*sizeof(char); i++)
        printf("0");
}

void printInBinary4(char n)
{
    int mask = 0x80, i=0;
    while (mask)
    {
        if (n & mask)
            printf("1");
        else
            printf("0");
        mask >>= 1;
        i++;
    }
    for ( ; i < 8*sizeof(char); i++)
        printf("0");
}`,
    question:
      "נרצה לכתוב פונקציה המקבלת `char` ומדפיסה את הביטים שלו כך שה־`MSB` יופיע משמאל וה־`LSB` יופיע מימין. הוצעו 4 מימושים שונים לפונקציה. איזה מימוש יבצע את הנדרש?",
    answers: [
      "שתיים או יותר מהתשובות האחרות נכונות",
      "`printInBinary3`",
      "`printInBinary2`",
      "`printInBinary4`",
      "`printInBinary1`",
      "אף תשובה אחרת אינה נכונה",
    ],
    correct: 0,
    hint: "בחנו כל פונקציה בנפרד. האם הלולאה מבטיחה לעבור על כל 8 הביטים? מה קורה במקרה קצה, למשל, כאשר הקלט הוא מספר שיש לו אפסים מובילים בייצוג הבינארי שלו (כמו 5, שהוא `00000101`)?",
    explanation:
      "שלושה מתוך ארבעת המימושים המוצעים (`printInBinary1`, `printInBinary3`, `printInBinary4`) יפיקו את הפלט הנכון, ולכן התשובה הנכונה היא 'שתיים או יותר מהתשובות האחרות נכונות'.\n\n**ניתוח הפונקציות:**\n* `printInBinary1`: מימוש זה נכון. הוא משתמש במסכה שמתחילה מהביט המשמעותי ביותר (`MSB`) וזזה ימינה בכל איטרציה. הלולאה תמיד רצה 8 פעמים ומבטיחה שכל 8 הביטים יודפסו כראוי.\n* `printInBinary2`: מימוש זה אינו נכון. הלולאה תפסיק לרוץ מוקדם מדי אם יישארו רק אפסים מובילים במספר, מכיוון שתנאי הלולאה `while(n)` יהפוך לשקרי. כתוצאה מכך, היא לא תדפיס את כל 8 הביטים עבור רוב המספרים.\n* `printInBinary3`: מימוש זה נכון. הלולאה הראשונה מזיזה את ביטי הקלט שמאלה ומדפיסה אותם כל עוד נותרו ביטים דולקים, והלולאה השנייה משלימה באפסים את יתרת הביטים עד להדפסת 8 ביטים בסך הכל.\n* `printInBinary4`: מימוש זה נכון מבחינת הפלט, אך פגום לוגית. הוא עובד כמו המימוש הראשון ומדפיס נכונה את כל 8 הביטים בלולאה הראשונה. הלולאה השנייה שנועדה להדפיס אפסים מיותרת ולעולם לא תתבצע, מפני שהלולאה הראשונה כבר מבצעת 8 איטרציות.",
  },
  {
    code: "",
    question:
      "נתון משתנה `x` מטיפוס `unsigned char` המכיל 3 ערכים במבנה `XXXYYYYZ`. מעוניינים להחליף בין שלושת הביטים `XXX` לארבעת הביטים `YYYY` כך שהמספר שיתקבל יהיה `YYYYXXXZ`. מה מהבאים יבצע את הפעולה:",
    answers: [
      "`x = ((x>>5) << 1) | ((x<<1) << 4);`",
      "`x = ((x<<5) >> 1) | ((x>>1) << 4);`",
      "`x = ((x>>5) << 1) | ((x<<1) >> 4);`",
      "`x = ((x<<5) >> 1) | ((x<<1) >> 4);`",
      "אף אחת מהתשובות אינה נכונה",
    ],
    correct: 4,
    hint: "כדי להחליף קבוצות של ביטים, יש לבודד כל קבוצה בנפרד, להזיז אותה למיקום החדש שלה, ורק אז לאחד את כל החלקים. בדקו האם הפקודות המוצעות מצליחות לבודד נכונה את קבוצות הביטים `XXX` ו-`YYYY` לפני שהן מזיזות אותן.",
    explanation:
      "הדרך הנכונה לבצע את ההחלפה היא באמצעות שלוש פעולות נפרדות שמאוחדות לבסוף. ראשית, יש לבודד כל קבוצת ביטים באמצעות מסכת `AND`, להזיז אותה למיקומה החדש, ולבסוף לאחד את כל החלקים עם `OR`. הפקודה הנכונה תהיה: `x = ((x & 0xE0) >> 4) | ((x & 0x1E) << 3) | (x & 0x01);`.\n\nאף אחת מהאפשרויות המוצעות אינה מבצעת את הפעולה כראוי. כולן מנסות להזיז את המספר `x` כולו (`x >> 5` או `x << 1`) מבלי לבודד תחילה את קבוצות הביטים. פעולת הזזה על המספר כולו גורמת לביטים מקבוצה אחת 'לגלוש' ולהשפיע על קבוצות אחרות, ובכך משבשת את התוצאה הסופית.\n\nמכיוון שכל הפקודות המוצעות משתמשות בלוגיקה שגויה של הזזת המספר השלם במקום הזזת קבוצות מבודדות, אף אחת מהן לא תניב את התוצאה הנדרשת.",
  },
  {
    code: `#define Q1(X) ( ( ((X) ^ 0x55555555) << 1) & 0xAAAAAAAA ) ^ ( (X) ^ 0xAAAAAAAA )

#define Q2(X) ( ( ((X) & 0x55555555) << 1) & 0xAAAAAAAA ) ^ ( (X) ^ 0xAAAAAAAA )

#define Q3(X) ( ( ((X) ^ 0x55555555) << 1) & 0xAAAAAAAA ) ^ ( (X) & 0xAAAAAAAA )

#define Q4(X) ( ( ((X) ^ 0x55555555) << 1) & 0xAAAAAAAA ) & ( (X) ^ 0xAAAAAAAA )`,
    question:
      "מעוניינים במאקרו אשר מחזיר ערך שונה מאפס אם הביטים במקומות הזוגיים (מיקום ה־`LSB` הוא 0) של משתנה `X` שווים ל־`bitwise not` של הביטים במקומות האי־זוגיים שלו, ומחזיר אפס אחרת. בהינתן ארבעת המאקרואים שמשמאל, ובהנחה ש־`X` הוא בגודל 4 בתים, איזו טענה היא הנכונה ביותר?",
    answers: [
      "אף תשובה מהתשובות האחרות אינה נכונה",
      "שתי תשובות או יותר מהאחרות נכונות",
      "רק `Q1` מבצע את הדרוש",
      "רק `Q2` מבצע את הדרוש",
      "רק `Q3` מבצע את הדרוש",
      "רק `Q4` מבצע את הדרוש",
    ],
    correct: 0,
    hint: "וואו, זאת השאלה הכי נוראית שנתקלתי בה. ואני אומר את זה בתור אחד שעבר על כל השאלות האמריקאיות מהחמישים המבחנים האחרונים.\nלגבי הרמז: התנאי שהמאקרו צריך לבדוק הוא שכל ביט זוגי הוא ההפך מהביט האי־זוגי שלידו. במקום לנתח את המאקרואים המסובכים, נסו לחשוב קודם מהי הדרך הפשוטה ביותר לממש את הבדיקה הזו. ישנם רק שני ערכים אפשריים שעונים על הדרישה.",
    explanation:
      "אף אחד מהמאקרואים המוצעים אינו מבצע את המשימה כראוי. הבעיה דורשת לבדוק אם כל זוג ביטים סמוכים הם הפוכים זה לזה. מצב זה מתקיים רק עבור שני ערכים קבועים: `0xAAAAAAAA` או `0x55555555`. לכן, הדרך הפשוטה והנכונה לבדוק זאת היא באמצעות הביטוי `((X) == 0xAAAAAAAA || (X) == 0x55555555)`.\n\nהמימושים המוצעים מורכבים מדי והלוגיקה שלהם שגויה. לדוגמה, אם נבדוק את `Q1` עם קלט לא חוקי כמו `0xFFFFFFFF` (שבו הביטים אינם הפוכים בזוגות), המאקרו יחזיר ערך שונה מאפס, בעוד שהיה אמור להחזיר אפס.\n\nהבעיה נובעת מכך שהפעולות המורכבות של הזזה ו-`XOR` אינן מבודדות נכונה את התכונה הנדרשת. אופרטור `XOR` אכן הופך ביט כאשר מבצעים `XOR` עם 1, ושומר על ערכו עם 0, אך האופן שבו הוא משולב כאן עם הזזות ופעולות `AND` ו-`OR` אינו מגיע לפתרון הנכון עבור כלל המקרים.",
  },
  {
    code: "",
    question:
      "מה תבצע השורה הבאה על משתנה `x` בגודל `byte` אחד: `x = (~(1 << (7-i)) & x);`?\n\n(שימו לב: הביטים ממוספרים מ-0, וימין נחשב ל־least significant bit)",
    answers: [
      "תכבה את הביט ה־i משמאל",
      "תדליק את הביט ה־i משמאל",
      "תכבה את הביט ה־i מימין",
      "כל התשובות האחרות אינן נכונות",
      "תדליק את הביט ה־i מימין",
    ],
    correct: 2,
    hint: "הביטוי `1 << k` יוצר מסכה עם ביט בודד דלוק במיקום `k`. פעולת `NOT` (`~`) הופכת את המסכה הזו למסכה עם ביט בודד כבוי. בדקו היטב איזה מיקום `k` מחושב כאן - האם זה `i` או `7-i`?",
    explanation:
      "הביטוי `(1 << (7-i))` יוצר מסכה עם ביט דלוק במיקום `7-i`. פעולת ה-`NOT` הופכת את המסכה כך שהיא מכילה `0` במיקום `7-i` ו-`1` בכל מקום אחר. פעולת `AND` עם `x` משתמשת במסכה זו כדי לכבות (לאפס) את הביט במיקום `7-i` של `x`.\n\nהביט במיקום `7-i` הוא למעשה הביט ה-`i` *משמאל*. לדוגמה, עבור `i=0`, הביט שכבה הוא `7-0=7`, שהוא הביט הכי שמאלי (MSB). לכן, הקוד המוצג מכבה את הביט ה-`i` משמאל.\n\nעם זאת, התשובה שנבחרה כנכונה היא כיבוי הביט ה-`i` *מימין*. ייתכן וקיימת טעות בשאלה, והכוונה הייתה לפקודה `x &= ~(1 << i);`. פקודה זו אכן מכבה את הביט ה-`i` מימין.",
  },
  {
    code: "",
    question:
      "מה תבצע השורה הבאה על משתנה `x` בגודל `byte` אחד: \n`x &= (~(1 << (7-i)) & x)`\n(הביטים ממוספרים מ-0, וימין נחשב ל־least significant bit)",
    answers: [
      "תכבה את הביט ה־i משמאל",
      "תדליק את הביט ה־i משמאל",
      "תכבה את הביט ה־i מימין",
      "כל התשובות האחרות אינן נכונות",
      "תדליק את הביט ה־i מימין",
    ],
    correct: 0,
    hint: "הפקודה `x &= y` היא קיצור תחבירי. לאחר שתפרשו אותה לצורתה המלאה, נתחו את המסכה שנוצרת על ידי הביטוי `~(1 << (7-i))` כדי להבין איזו פעולה היא מבצעת על `x`.",
    explanation:
      "הפקודה `x &= y;` היא קיצור תחבירי ל-`x = x & y;`, כלומר היא מבצעת פעולת `AND` בינארית בין `x` לבין המסכה `~(1 << (7-i))`.\n\nהביטוי `(1 << (7-i))` יוצר מסכה עם ביט `1` בודד במיקום ה-`i` משמאל. לדוגמה, עבור `i=0`, הביטוי הוא `1 << 7`, והביט הדלוק הוא במיקום 7, שהוא הביט הכי שמאלי (MSB).\n\nפעולת ה-`NOT` (`~`) הופכת את המסכה, כך שנוצרת מסכה חדשה עם ביט `0` בודד במיקום ה-`i` משמאל, וביטים של `1` בכל שאר המקומות. פעולת `AND` בין `x` למסכה זו שומרת על כל הביטים המקוריים של `x` אך מאפסת (מכבה) את הביט ה-`i` משמאל.",
  },
  {
    code: "",
    question: "מה יהיה ערך הביטוי הבא?\n`1 << 1 << 1 ^ 1 >> 1 << 1`",
    answers: ["4", "2", "1", "0", "כל התשובות האחרות אינן נכונות"],
    correct: 0,
    hint: "כדי לפתור את השאלה, יש לפעול לפי סדר קדימויות האופרטורים. אם אינכם זוכרים את סדר הקדימויות, הכל בסדר, הוא מופיע בעמוד האחרון של דף הנוסחאות המעודכן.",
    explanation:
      "החישוב מתבצע לפי כללי קדימות האופרטורים. לאופרטורי הזזת הביטים (`<<` ו-`>>`) יש קדימות גבוהה יותר מאשר לאופרטור `XOR` (`^`).\n\nהביטוי מתחלק לשני חלקים שסביב ה-`XOR`: `(1 << 1 << 1)` ו-`(1 >> 1 << 1)`.\n* החלק השמאלי: `1 << 1` נותן `2`, ולאחר מכן `2 << 1` נותן `4`.\n* החלק הימני: `1 >> 1` נותן `0`, ולאחר מכן `0 << 1` נותן `0`.\n\nלבסוף, מתבצעת פעולת ה-`XOR` על התוצאות: `4 ^ 0`. התוצאה הסופית היא `4`.",
  },
  {
    code: `unsigned char BuildMask(int size)
{
    int i;
    unsigned char mask = 0;
    for (i = 0; i < size; i++)
    {
        mask = mask << 1;
        mask = mask | 1;
    }
    return mask;
}

unsigned char f(unsigned char c, int size)
{
    unsigned char mask = BuildMask(size);
    c = ( (c & mask) << (8-size) ) | ( (c & ~mask) >> size);
    return c;
}`,
    question:
      "מה מבצעת הפונקציה `f` שמקבלת `c` ו-`size` (בהינתן ש-`size` הוא מספר בין 1 ל-7 כולל) על המשתנה `c`?",
    answers: [
      "`דוחפת` את `8-size` הביטים התחתונים `size` מקומות שמאלה",
      "`דוחפת` את `size` הביטים התחתונים `8-size` מקומות שמאלה",
      "מחליפה בין `size` הביטים התחתונים ל־`8-size` הביטים העליונים",
      "יתר התשובות אינן נכונות",
      "מחליפה בין `size` הביטים העליונים ל־`8-size` הביטים התחתונים",
    ],
    correct: 2,
    hint: "נתחו את שני חלקי הביטוי שמימין להשמה בנפרד. החלק הראשון, `(c & mask)`, מבודד קבוצת ביטים מסוימת ומזיז אותה. החלק השני, `(c & ~mask)`, מבודד את קבוצת הביטים הנותרת ומזיז אותה. מהי הפעולה הכוללת שמתקבלת מאיחוד שתי התוצאות?",
    explanation:
      "הפונקציה `f` מבצעת החלפה בין שתי קבוצות של ביטים בתוך המשתנה `c`.\n\nהפונקציה `BuildMask` יוצרת מסכה עם `size` ביטים דלוקים בערך הנמוך. הביטוי `(c & mask)` מבודד את `size` הביטים התחתונים (LSBs) של `c`. לאחר מכן, `<< (8-size)` מזיז את הביטים הללו לקצה השמאלי (העליון) של התוצאה.\n\nבמקביל, הביטוי `(c & ~mask)` מבודד את `8-size` הביטים העליונים (MSBs) של `c`. לאחר מכן, `>> size` מזיז את הביטים הללו לקצה הימני (התחתון) של התוצאה.\n\nפעולת ה-`OR` (`|`) מאחדת את שתי התוצאות, ובכך משלימה את פעולת ההחלפה: `size` הביטים שהיו למטה עברו למעלה, ו-`8-size` הביטים שהיו למעלה עברו למטה.",
  },
];
